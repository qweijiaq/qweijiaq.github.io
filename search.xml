<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>06 集合引用类型</title>
      <link href="/posts/6.html"/>
      <url>/posts/6.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-Object"><a href="#1-Object" class="headerlink" title="1. Object"></a>1. Object</h3><p>Object 是 ECMAScript 中最常用的类型之一，显式创建 Object 的实例有两种方式：</p><ul><li>使用 <code>new</code> 操作符和 <code>Object</code> 构造函数，如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><ul><li>直接使用字面量，如：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义空对象</span></span><br><span class="line"><span class="keyword">let</span> empty = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>在字面量表示法中，属性名可以是字符串或数值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="number">5</span>: <span class="literal">true</span>            <span class="comment">// 数值类型会自动转换为字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用字面量表示法定义对象时，不会实际调用 <code>Object</code> 构造函数，实际开发中也倾向于使用对象字面量表示法定义对象。</p><p>事实上，对象字面量已经成为给函数传递大量可选参数的主要方式，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">displayInfo</span>(<span class="params">args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args.<span class="property">name</span> == <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">        output += <span class="string">&quot;Name: &quot;</span> + args.<span class="property">name</span> + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> args.<span class="property">age</span> == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        output += <span class="string">&quot;Age: &quot;</span> + args.<span class="property">age</span> + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">alert</span>(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">displayInfo</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">displayInfo</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>虽然属性一般是通过<strong>点语法</strong>来存取的，这也是面向对象语言的惯例，但也可以使用中括号来存取属性。在使用中括号时，要在括号内使用属性名的字符串形式，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[<span class="string">&quot;name&quot;</span>]);  <span class="comment">// &quot;Tom&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);     <span class="comment">// &quot;Tom&quot;</span></span><br></pre></td></tr></table></figure><p>使用中括号的主要优势就是可以通过变量访问属性，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[propertyName]);  <span class="comment">// &quot;Tom&quot;</span></span><br></pre></td></tr></table></figure><p>另外，如果属性名中包含可能会导致语法错误的字符，或者包含关键字 / 保留字时，也可以使用中括号语法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">&quot;first name&quot;</span>] = <span class="string">&quot;Nicholas&quot;</span>;   <span class="comment">// 空格不是合法字符</span></span><br></pre></td></tr></table></figure><p>优先使用点语法，必要时才使用中括号方式。</p><h3 id="2-Array"><a href="#2-Array" class="headerlink" title="2. Array"></a>2. Array</h3><p>除了 Object，Array 是 ECMAScript 中最常用的类型。跟其他语言中的数组一样，ECMAScript 数组也是一组有序的数据，但跟其他语言不同的是，数组中每个槽位可以存储任意类型的数据。ECMAScript 数组也是动态大小的，会随着数据添加而自动增长。</p><h4 id="2-1-创建数组"><a href="#2-1-创建数组" class="headerlink" title="2.1 创建数组"></a>2.1 创建数组</h4><p>第一种构建数组的方式是使用构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);<span class="comment">// 如果只给构造函数传一个数值, 则该数表示数组的长度, 即 length 属性</span></span><br><span class="line"><span class="keyword">let</span> arr3 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;one&quot;</span>);<span class="comment">// 传入一个非数值时, 则其为元素, 即 arr3 = [&quot;one&quot;]</span></span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);<span class="comment">// 传入多个值时, 它们均为数组的元素, 即 arr4 = [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>在使用 Array 构造函数时，也可以省略 <code>new</code> 操作符，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="title class_">Array</span>(<span class="number">3</span>);      <span class="comment">// 创建一个包含 3 个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> names = <span class="title class_">Array</span>(<span class="string">&quot;Greg&quot;</span>); <span class="comment">// 创建一个只包含一个元素，即字符串 &quot;Greg&quot; 的数组</span></span><br></pre></td></tr></table></figure><p>另一种创建数组的方式是使用数组字面量表示法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];   <span class="comment">// 创建一个包含 3 个元素的数组</span></span><br><span class="line"><span class="keyword">let</span> names = [];                             <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>, ];                       <span class="comment">// 创建一个包含 2 个元素的数组 -- 数组最后一个元素后可以加逗号</span></span><br></pre></td></tr></table></figure><blockquote><p>  与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。</p></blockquote><p>Array 构造函数在 ES6 中新增了用于创建数组的静态方法：<code>from()</code> 和 <code>of()</code>。<code>from()</code> 用于将类数组结构转换为数组实例，而 <code>of()</code> 用于将一组参数转换为数组实例。</p><p><code>Array.from()</code> 的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 <code>length</code> 属性和可索引元素的结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串会被拆分为单字符数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="string">&quot;Matt&quot;</span>)); <span class="comment">// [&quot;M&quot;, &quot;a&quot;, &quot;t&quot;, &quot;t&quot;]</span></span><br><span class="line"><span class="comment">// 可以使用 from() 将集合和映射转换为一个新数组</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>().<span class="title function_">set</span>(<span class="number">1</span>, <span class="number">2</span>).<span class="title function_">set</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="number">1</span>).<span class="title function_">add</span>(<span class="number">2</span>).<span class="title function_">add</span>(<span class="number">3</span>).<span class="title function_">add</span>(<span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(m)); <span class="comment">// [[1, 2], [3, 4]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(s)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// Array.from() 对现有数组执行浅复制</span></span><br><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a1);        <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="title function_">alert</span>(a1 === a2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 可以使用任何可迭代对象</span></span><br><span class="line"><span class="keyword">const</span> iter = &#123;</span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(iter)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// arguments 对象可以被轻松地转换为数组</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getArgsArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getArgsArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// from() 也能转换带有 length 属性的自定义对象</span></span><br><span class="line"><span class="keyword">const</span> arrayLikeObject = &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="number">2</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="number">3</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(arrayLikeObject)); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure><p><code>Array.from()</code> 还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用 <code>Array.from().map()</code> 那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中 <code>this</code> 的值，但这个重写的 <code>this</code> 值在箭头函数中不适用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="function"><span class="params">x</span> =&gt;</span> x**<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> a3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(a1, <span class="keyword">function</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x ** <span class="variable language_">this</span>.<span class="property">exponent</span>&#125;, &#123;<span class="attr">exponent</span>: <span class="number">2</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a2);   <span class="comment">// [1, 4, 9, 16]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a3);   <span class="comment">// [1, 4, 9, 16]</span></span><br></pre></td></tr></table></figure><p><code>Array.of()</code> 可以把一组参数转换为数组，该方法用于替代在 ES6 之前常用的 <code>Array.prototype.slice.call(arguments)</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="literal">undefined</span>));   <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure><h4 id="2-2-数组空位"><a href="#2-2-数组空位" class="headerlink" title="2.2 数组空位"></a>2.2 数组空位</h4><p>可以像下面这样创建一个空位数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [,,,,,]; <span class="comment">// 创建包含5 个元素的数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="property">length</span>);    <span class="comment">// 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options);           <span class="comment">// [,,,,,]</span></span><br></pre></td></tr></table></figure><p>ES6 新增的方法和迭代器与早期 ECMAScript 版本中存在的方法行为不同。ES6 新增方法普遍将这些空位当成存在的元素，只不过值为 <code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>,,,,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> option <span class="keyword">of</span> options) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(option === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="title class_">Array</span>.<span class="title function_">from</span>([, , , ]); <span class="comment">// 使用 ES6 的Array.from() 创建的包含 3 个空位的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> val <span class="keyword">of</span> a) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(val === <span class="literal">undefined</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Array</span>.<span class="title function_">of</span>(...[, , , ])); <span class="comment">// [undefined, undefined, undefined]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [index, value] <span class="keyword">of</span> options.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>ES6 之前的方法则会忽略这个空位，但具体的行为也会因方法而异：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = [<span class="number">1</span>, , , ,<span class="number">5</span>];</span><br><span class="line"><span class="comment">// map() 会跳过空位置</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="number">6</span>));   <span class="comment">// [6, undefined, undefined, undefined, 6]</span></span><br><span class="line"><span class="comment">// join() 视空位置为空字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(options.<span class="title function_">join</span>(<span class="string">&#x27;-&#x27;</span>));      <span class="comment">// &quot;1----5&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>  由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要空位，则可以显式地用 <code>undefined</code> 值代替。</p></blockquote><h4 id="2-3-数组索引"><a href="#2-3-数组索引" class="headerlink" title="2.3 数组索引"></a>2.3 数组索引</h4><p>要取得或设置数组的值，需要使用中括号并提供相应值的数字索引，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];<span class="comment">// 定义一个字符串数组</span></span><br><span class="line"><span class="title function_">alert</span>(colors[<span class="number">0</span>]);                           <span class="comment">// 显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">&quot;black&quot;</span>;                        <span class="comment">// 修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">&quot;brown&quot;</span>;                        <span class="comment">// 添加第四项</span></span><br></pre></td></tr></table></figure><p>如果索引小于数组包含的元素数，则返回存储在相应位置的元素；如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加 1。</p><p>数组中元素的数量保存在 <code>length</code> 属性中，这个属性始终返回 0 或大于 0 的值，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];<span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="keyword">let</span> names = [];                         <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>);<span class="comment">// 3</span></span><br><span class="line"><span class="title function_">alert</span>(names.<span class="property">length</span>);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>数组 <code>length</code> 属性的独特之处在于，它不是只读的。通过修改 <code>length</code> 属性，可以从数组末尾删除或添加元素。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">alert</span>(colors[<span class="number">2</span>]);  <span class="comment">// undefined -- 访问不存在的索引时返回 undefined</span></span><br><span class="line"></span><br><span class="line">colors.<span class="property">length</span> = <span class="number">4</span>;</span><br><span class="line"><span class="title function_">alert</span>(colors[<span class="number">3</span>]);  <span class="comment">// undefined -- 在末尾补 undefined</span></span><br></pre></td></tr></table></figure><p>使用 <code>length</code> 属性可以方便地向数组末尾添加元素，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];   <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors[colors.<span class="property">length</span>] = <span class="string">&quot;black&quot;</span>;          <span class="comment">// 添加一种颜色（位置 3）</span></span><br><span class="line">colors[colors.<span class="property">length</span>] = <span class="string">&quot;brown&quot;</span>;          <span class="comment">// 再添加一种颜色（位置 4）</span></span><br></pre></td></tr></table></figure><p>数组中最后一个元素的索引始终是 <code>length - 1</code>，因此下一个新增槽位的索引就是 <code>length</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];  <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">&quot;black&quot;</span>;                  <span class="comment">// 添加一种颜色（位置 99）</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>);                   <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><blockquote><p>  数组最多可以包含 4294967295 个元素。</p></blockquote><h4 id="2-4-检测数组"><a href="#2-4-检测数组" class="headerlink" title="2.4 检测数组"></a>2.4 检测数组</h4><p>一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（即只有一个全局作用域）的情况下，使用 <code>instanceof</code> 操作符就足矣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">    <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>instanceof</code> 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。为解决这个问题，ECMAScript 提供了 <code>Array.isArray()</code> 方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value))&#123;</span><br><span class="line">    <span class="comment">// 操作数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-迭代器方法"><a href="#2-5-迭代器方法" class="headerlink" title="2.5 迭代器方法"></a>2.5 迭代器方法</h4><p>在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：<code>keys()</code>、<code>values()</code> 和 <code>entries()</code>。<code>keys()</code> 返回数组索引的迭代器，<code>values()</code> 返回数组元素的迭代器，而 <code>entries()</code> 返回索引 / 值对的迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"><span class="comment">// 因为这些方法都返回迭代器，所以可以将它们的内容通过 Array.from() 直接转换为数组实例</span></span><br><span class="line"><span class="keyword">const</span> aKeys = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">keys</span>());</span><br><span class="line"><span class="keyword">const</span> aValues = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">values</span>());</span><br><span class="line"><span class="keyword">const</span> aEntries = <span class="title class_">Array</span>.<span class="title function_">from</span>(a.<span class="title function_">entries</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aKeys);      <span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aValues);    <span class="comment">// [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(aEntries);   <span class="comment">// [[0, &quot;foo&quot;], [1, &quot;bar&quot;], [2, &quot;baz&quot;], [3, &quot;qux&quot;]]</span></span><br></pre></td></tr></table></figure><p>使用 ES6 的解构可以非常容易地在循环中拆分键 / 值对：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>, <span class="string">&quot;qux&quot;</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [idx, element]<span class="keyword">of</span> a.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(idx);</span><br><span class="line">    <span class="title function_">alert</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// bar</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// baz</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// qux</span></span><br></pre></td></tr></table></figure><h4 id="2-6-复制和填充方法"><a href="#2-6-复制和填充方法" class="headerlink" title="2.6 复制和填充方法"></a>2.6 复制和填充方法</h4><p>ES6 新增了两个方法：批量复制方法 <code>copyWithin()</code>，以及填充数组方法 <code>fill()</code>。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。</p><p>使用 <code>fill()</code> 方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 用 5 填充整个数组</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes);   <span class="comment">// [5, 5, 5, 5, 5]</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>);       <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 6 填充索引大于等于 3 的元素</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">6</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes);   <span class="comment">// [0, 0, 0, 6, 6]</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>);         <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 7 填充索引大于等于 1 且小于 3 的元素</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes);   <span class="comment">// [0, 7, 7, 0, 0];</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">0</span>);         <span class="comment">// 重置</span></span><br><span class="line"><span class="comment">// 用 8 填充索引大于等于 1 且小于 4 的元素</span></span><br><span class="line"><span class="comment">// (-4 + zeroes.length = 1)</span></span><br><span class="line"><span class="comment">// (-1 + zeroes.length = 4)</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">8</span>, -<span class="number">4</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes);   <span class="comment">// [0, 8, 8, 8, 0];</span></span><br></pre></td></tr></table></figure><p><code>fill()</code> 静默忽略超出数组边界、零长度及方向相反的索引范围：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> zeroes = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">6</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes);   <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes);   <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes);   <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">// 索引部分可用，填充可用部分</span></span><br><span class="line">zeroes.<span class="title function_">fill</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(zeroes);   <span class="comment">// [0, 0, 0, 4, 4]</span></span><br></pre></td></tr></table></figure><p>与 <code>fill()</code> 不同，<code>copyWithin()</code> 会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 <code>fill()</code> 使用同样的计算方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,</span><br><span class="line">    reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始的内容，插入到索引 5 开始的位置</span></span><br><span class="line"><span class="comment">// 在源索引或目标索引到达数组边界时停止</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints);   <span class="comment">// [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// 从 ints 中复制索引 5 开始的内容，插入到索引 0 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ints);   <span class="comment">// [5, 6, 7, 8, 9, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// 从 ints 中复制索引 0 开始到索引 3 结束的内容</span></span><br><span class="line"><span class="comment">// 插入到索引 4 开始的位置</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">alert</span>(ints);   <span class="comment">// [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// JavaScript 引擎在插值前会完整复制范围内的值</span></span><br><span class="line"><span class="comment">// 因此复制期间不存在重写的风险</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="title function_">alert</span>(ints);   <span class="comment">// [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// 支持负索引值，与 fill() 相对于数组末尾计算正向索引的过程是一样的</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(-<span class="number">4</span>, -<span class="number">7</span>, -<span class="number">3</span>);</span><br><span class="line"><span class="title function_">alert</span>(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><code>copyWithin()</code> 静默忽略超出数组边界、零长度及方向相反的索引范围：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints,</span><br><span class="line">    reset = <span class="function">() =&gt;</span> ints = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// 索引过低，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">1</span>, -<span class="number">15</span>, -<span class="number">12</span>);</span><br><span class="line"><span class="title function_">alert</span>(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span></span><br><span class="line"><span class="title function_">reset</span>()</span><br><span class="line"><span class="comment">// 索引过高，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">1</span>, <span class="number">12</span>, <span class="number">15</span>);</span><br><span class="line"><span class="title function_">alert</span>(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// 索引反向，忽略</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">alert</span>(ints);   <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];</span></span><br><span class="line"><span class="title function_">reset</span>();</span><br><span class="line"><span class="comment">// 索引部分可用，复制、填充可用部分</span></span><br><span class="line">ints.<span class="title function_">copyWithin</span>(<span class="number">4</span>, <span class="number">7</span>, <span class="number">10</span>)</span><br><span class="line"><span class="title function_">alert</span>(ints);   <span class="comment">// [0, 1, 2, 3, 7, 8, 9, 7, 8, 9];</span></span><br></pre></td></tr></table></figure><h4 id="2-7-转换方法"><a href="#2-7-转换方法" class="headerlink" title="2.7 转换方法"></a>2.7 转换方法</h4><p>所有对象都有 <code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法。<code>valueOf()</code> 返回的还是数组本身，而 <code>toString()</code> 返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>]; <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">toString</span>());    <span class="comment">// &quot;red,blue,green&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">valueOf</span>());     <span class="comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span></span><br><span class="line"><span class="title function_">alert</span>(colors);               <span class="comment">// red,blue,green -- alert() 期待字符串，所以会在后台调用数组的 toString() 方法</span></span><br></pre></td></tr></table></figure><p><code>toLocaleString()</code> 方法也可能返回跟 <code>toString()</code> 和 <code>valueOf()</code> 相同的结果，但也不一定。在调用数组的 <code>toLocaleString()</code> 方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的 <code>toLocaleString()</code> 方法，而不是 <code>toString()</code> 方法。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line">    <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Nikolaos&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person2 = &#123;</span><br><span class="line">    <span class="title function_">toLocaleString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Grigorios&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> people = [person1, person2];</span><br><span class="line"><span class="title function_">alert</span>(people);                        <span class="comment">// Nicholas,Greg</span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toString</span>());          <span class="comment">// Nicholas,Greg</span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">toLocaleString</span>());   <span class="comment">// Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure><p>默认返回以逗号为分隔符的字符串，如果想使用不同的分隔符，则可以使用 <code>join()</code> 方法。<code>join()</code> 方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;, &quot;</span>));      <span class="comment">// red, green, blue</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="title function_">join</span>(<span class="string">&quot;||&quot;</span>));     <span class="comment">// red||green||blue</span></span><br></pre></td></tr></table></figure><blockquote><p>  如果数组中某一项是 <code>null</code> 或 <code>undefined</code>，则在 <code>join()</code>、<code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code> 返回的结果中会以空字符串表示。</p></blockquote><h4 id="2-8-栈方法"><a href="#2-8-栈方法" class="headerlink" title="2.8 栈方法"></a>2.8 栈方法</h4><p><code>push()</code> 方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度；<code>pop()</code> 方法则用于删除数组的最后一项，同时减少数组的 <code>length</code> 值，返回被删除的项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>();               <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);   <span class="comment">// 推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count);                               <span class="comment">// 2</span></span><br><span class="line">count = colors.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);   <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count);                       <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>();         <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="title function_">alert</span>(item);                        <span class="comment">// &quot;black&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>);             <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="2-9-队列方法"><a href="#2-9-队列方法" class="headerlink" title="2.9 队列方法"></a>2.9 队列方法</h4><p><code>shift()</code> 会删除数组的第一项并返回它，然后数组长度减 1。使用 <code>shift()</code> 和 <code>push()</code>，可以把数组当成队列来使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>();                <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">push</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);   <span class="comment">// 推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count);                               <span class="comment">// 2</span></span><br><span class="line">count = colors.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count);                     <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">shift</span>();   <span class="comment">// 取得第一项</span></span><br><span class="line"><span class="title function_">alert</span>(item);                    <span class="comment">// red</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>);         <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>ECMAScript 也为数组提供了 <code>unshift()</code> 方法，即执行跟 <code>shift()</code> 相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 <code>unshift()</code> 和 <code>pop()</code>，可以在相反方向上模拟队列，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="keyword">new</span> <span class="title class_">Array</span>();                    <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">let</span> count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>);   <span class="comment">// 从数组开头推入两项</span></span><br><span class="line"><span class="title function_">alert</span>(count);                                   <span class="comment">// 2 -- [&quot;red&quot;, &quot;green&quot;]</span></span><br><span class="line">count = colors.<span class="title function_">unshift</span>(<span class="string">&quot;black&quot;</span>);   <span class="comment">// 再推入一项</span></span><br><span class="line"><span class="title function_">alert</span>(count);                          <span class="comment">// 3 -- [&quot;black&quot;, &quot;red&quot;, &quot;green&quot;]</span></span><br><span class="line"><span class="keyword">let</span> item = colors.<span class="title function_">pop</span>();   <span class="comment">// 取得最后一项</span></span><br><span class="line"><span class="title function_">alert</span>(item);                  <span class="comment">// green</span></span><br><span class="line"><span class="title function_">alert</span>(colors.<span class="property">length</span>);      <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h4 id="2-10-排序方法"><a href="#2-10-排序方法" class="headerlink" title="2.10 排序方法"></a>2.10 排序方法</h4><p><code>reverse()</code> 方法将数组元素反向排列，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="title function_">alert</span>(values);   <span class="comment">// [5,4,3,2,1]</span></span><br></pre></td></tr></table></figure><p>默认情况下，<code>sort()</code> 会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，<code>sort()</code> 会在每一项上调用 <code>String()</code> 转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>();</span><br><span class="line"><span class="title function_">alert</span>(values);   <span class="comment">// [0,1,10,15,5] -- 首先一次比较第一个字符，第一个字符相等时才考虑比较第二个字符</span></span><br></pre></td></tr></table></figure><p><code>sort()</code> 方法可以接收一个比较函数，用于判断哪个值应该排在前面。比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较函数可以适用于大多数数据类型，可以把它当作参数传给 <code>sort()</code> 方法，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values);   <span class="comment">// [0,1,5,10,15]</span></span><br></pre></td></tr></table></figure><p>当然，比较函数也可以产生降序效果，只要把返回值交换一下即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">        return1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span>-<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.<span class="title function_">sort</span>(compare);</span><br><span class="line"><span class="title function_">alert</span>(values);   <span class="comment">// [15,10,5,1,0]</span></span><br></pre></td></tr></table></figure><blockquote><p>  如果只是想反转数组的顺序，<code>reverse()</code> 更简单也更快。</p></blockquote><p><code>reverse()</code> 和 <code>sort()</code> 都是原地修改数组。</p><p>如果数组的元素是数值，或者是其 <code>valueOf()</code> 方法返回数值的对象（如 <code>Date</code> 对象），这个比较函数还可以简写，可以直接用第二个值减去第一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">value1, value2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-11-操作方法"><a href="#2-11-操作方法" class="headerlink" title="2.11 操作方法"></a>2.11 操作方法</h4><p><code>concat()</code> 方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则 <code>concat()</code> 会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>]);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);    <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2);   <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></span><br></pre></td></tr></table></figure><p>打平数组参数的行为可以重写，方法是在参数数组上指定一个特殊的符号：<code>Symbol.isConcat-Spreadable</code>。这个符号能够阻止 <code>concat()</code> 打平参数数组。相反，把这个值设置为 <code>true</code> 可以强制打平类数组对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> newColors = [<span class="string">&quot;black&quot;</span>, <span class="string">&quot;brown&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> moreNewColors = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="number">0</span>: <span class="string">&quot;pink&quot;</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">&quot;cyan&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">newColors[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// 强制不打平数组</span></span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">concat</span>(<span class="string">&quot;yellow&quot;</span>, newColors);</span><br><span class="line"><span class="comment">// 强制打平类数组对象</span></span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">concat</span>(moreNewColors);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors);    <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors2);   <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors3);   <span class="comment">// [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;pink&quot;, &quot;cyan&quot;]</span></span><br></pre></td></tr></table></figure><p>方法 <code>slice()</code> 用于创建一个包含原有数组中一个或多个元素的新数组。<code>slice()</code> 方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 <code>slice()</code> 会返回该索引到数组末尾的所有元素。如果有两个参数，则 <code>slice()</code> 返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。<strong>这个操作不影响原始数组</strong>。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;purple&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> colors2 = colors.<span class="title function_">slice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> colors3 = colors.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"><span class="title function_">alert</span>(colors2);   <span class="comment">// green, blue, yellow, purple</span></span><br><span class="line"><span class="title function_">alert</span>(colors3);   <span class="comment">// green, blue, yellow</span></span><br></pre></td></tr></table></figure><p>如果 <code>slice()</code> 的参数有负值，那么就以数值长度加上这个负值的结果确定位置。</p><p><code>splice()</code> 的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法。</p><ul><li>删除：需要给 <code>splice()</code> 传 2 个参数，即要删除的第一个元素的位置和要删除的元素数量。</li><li>插入：需要给 <code>splice()</code> 传 3 个参数，即开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。</li><li>替换：<code>splice()</code> 在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数，即开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。</li></ul><p><code>splice()</code> 方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> removed = colors.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">1</span>);   <span class="comment">// 删除第一项</span></span><br><span class="line"><span class="title function_">alert</span>(colors);                     <span class="comment">// green, blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed);                     <span class="comment">// red，只有一个元素的数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;orange&quot;</span>);    <span class="comment">// 在位置1 插入两个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors);                                      <span class="comment">// green, yellow, orange, blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed);                                         <span class="comment">// 空数组</span></span><br><span class="line">removed = colors.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;red&quot;</span>, <span class="string">&quot;purple&quot;</span>);   <span class="comment">// 插入两个值，删除一个元素</span></span><br><span class="line"><span class="title function_">alert</span>(colors);                                          <span class="comment">// green, red, purple, orange, blue</span></span><br><span class="line"><span class="title function_">alert</span>(removed);                                         <span class="comment">// yellow，只有一个元素的数组</span></span><br></pre></td></tr></table></figure><h4 id="2-12-搜索和位置方法"><a href="#2-12-搜索和位置方法" class="headerlink" title="2.12 搜索和位置方法"></a>2.12 搜索和位置方法</h4><p>ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。</p><ol><li><p>严格相等</p><p>ECMAScript 提供了 3 个严格相等的搜索方法：<code>indexOf()</code>、<code>lastIndexOf()</code> 和 <code>includes()</code>。其中，前两个方法在所有版本中都可用，而第三个方法是 ES 7 新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。</p><p><code>indexOf()</code>和 <code>includes()</code> 方法从数组前头（第一项）开始向后搜索，而 <code>lastIndexOf()</code> 从数组末尾（最后一项）开始向前搜索。</p><p><code>indexOf()</code> 和 <code>lastIndexOf()</code> 都返回要查找的元素在数组中的位置，如果没找到则返回 <code>-1</code>。<code>includes()</code> 返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等 <code>===</code> 比较，也就是说两项必须严格相等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>));            <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>));        <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>));           <span class="comment">// true</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">indexOf</span>(<span class="number">4</span>, <span class="number">4</span>));         <span class="comment">// 5</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">lastIndexOf</span>(<span class="number">4</span>, <span class="number">4</span>));    <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">alert</span>(numbers.<span class="title function_">includes</span>(<span class="number">4</span>, <span class="number">7</span>));        <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> people = [&#123; <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> morePeople = [person];</span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">indexOf</span>(person));        <span class="comment">// -1 -- people 内部的对象和 person 不是同一个对象</span></span><br><span class="line"><span class="title function_">alert</span>(morePeople.<span class="title function_">indexOf</span>(person));   <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">includes</span>(person));      <span class="comment">// false</span></span><br><span class="line"><span class="title function_">alert</span>(morePeople.<span class="title function_">includes</span>(person)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>断言函数</p><p>ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。</p><p>断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。</p><p><code>find()</code> 和 <code>findIndex()</code> 方法使用了断言函数。这两个方法都从数组的最小索引开始。<code>find()</code> 返回第一个匹配的元素，<code>findIndex()</code> 返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 <code>this</code> 的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> people = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Matt&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">27</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">29</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// &#123;name: &quot;Matt&quot;, age: 27&#125;</span></span><br><span class="line"><span class="title function_">alert</span>(people.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> element.<span class="property">age</span> &lt; <span class="number">28</span>));</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>找到匹配项后，这两个方法都不再继续搜索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> evens = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// 找到匹配后，永远不会检查数组的最后一个元素</span></span><br><span class="line">evens.<span class="title function_">find</span>(<span class="function">(<span class="params">element, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(element);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">    <span class="keyword">return</span> element === <span class="number">4</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-13-迭代方法"><a href="#2-13-迭代方法" class="headerlink" title="2.13 迭代方法"></a>2.13 迭代方法</h4><p>ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 <code>this</code> 的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。数组的 5 个迭代方法如下：</p><ul><li><code>every()</code>：对数组每一项都运行传入的函数，如果对每一项函数都返回 <code>true</code>，则这个方法返回 <code>true</code>。</li><li><code>filter()</code>：对数组每一项都运行传入的函数，函数返回 <code>true</code> 的项会组成数组之后返回。</li><li><code>forEach()</code>：对数组每一项都运行传入的函数，没有返回值。</li><li><code>map()</code>：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。</li><li><code>some()</code>：对数组每一项都运行传入的函数，如果有一项函数返回 <code>true</code>，则这个方法返回 <code>true</code>。</li></ul><p>这些方法都不改变调用它们的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> everyResult = numbers.<span class="title function_">every</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="title function_">alert</span>(everyResult);   <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someResult = numbers.<span class="title function_">some</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="title function_">alert</span>(someResult);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> filterResult = numbers.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item &gt; <span class="number">2</span>);</span><br><span class="line"><span class="title function_">alert</span>(filterResult);   <span class="comment">// 3,4,5,4,3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapResult = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> item ＊ <span class="number">2</span>);</span><br><span class="line"><span class="title function_">alert</span>(mapResult);   <span class="comment">// 2,4,6,8,10,8,6,4,2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach() 方法相当于使用 for 循环遍历数组并执行相应操作</span></span><br><span class="line">numbers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="2-14-归并方法"><a href="#2-14-归并方法" class="headerlink" title="2.14 归并方法"></a>2.14 归并方法</h4><p>ECMAScript 为数组提供了两个归并方法：<code>reduce()</code> 和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。<code>reduce()</code> 方法从数组第一项开始遍历到最后一项，而 <code>reduceRight()</code> 从最后一项开始遍历至第一项。</p><p>这两个方法都接收两个参数：对每一项都会运行的归并函数，以及可选的以之为归并起点的初始值。传给 <code>reduce()</code> 和 <code>reduceRight()</code> 的函数接收 4 个参数：上一个归并值、当前项、当前项的索引和数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。如果没有给这两个方法传入可选的第二个参数（作为归并起点值），则第一次迭代将从数组的第二项开始，因此传给归并函数的第一个参数是数组的第一项，第二个参数是数组的第二项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index, array</span>) =&gt;</span> prev + cur);</span><br><span class="line"><span class="title function_">alert</span>(sum);   <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p><code>reduceRight()</code> 方法与之类似，只是方向相反，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> sum = values.<span class="title function_">reduceRight</span>(<span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">alert</span>(sum); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><h3 id="3-定型数组"><a href="#3-定型数组" class="headerlink" title="3. 定型数组"></a>3. 定型数组</h3><p>定型数组 (typed array) 是 ECMAScript 新增的结构，目的是提升向原生库传输数据的效率。实际上，JavaScript 并没有 “TypedArray” 类型，它所指的其实是一种特殊的包含数值类型的数组。</p><h4 id="3-1-历史"><a href="#3-1-历史" class="headerlink" title="3.1 历史"></a>3.1 历史</h4><p>随着浏览器的流行，人们期待通过它来运行复杂的 3D 应用程序。早在 2006 年，Mozilla、Opera等浏览器提供商就实验性地在浏览器中增加了用于渲染复杂图形应用程序的编程平台，无须安装任何插件。其目标是开发一套 JavaScript API，从而充分利用 3D 图形 API 和 GPU 加速，以便在 <code>&lt;canvas&gt;</code> 元素上渲染复杂的图形。</p><p>最后的 JavaScript API 是基于 OpenGL ES (OpenGL for Embedded Systems) 2.0 规范的。OpenGL ES 是 OpenGL 专注于 2D 和 3D 计算机图形的子集。这个新 API 被命名为 <strong>WebGL</strong> (Web Graphics Library)，于 2011 年发布 1.0 版。有了它，开发者就能够编写涉及复杂图形的应用程序，它会被兼容 WebGL 的浏览器原生解释执行。</p><p>在 WebGL 的早期版本中，因为 JavaScript 数组与原生数组之间不匹配，所以出现了性能问题。图形驱动程序 API 通常不需要以 JavaScript 默认双精度浮点格式传递给它们的数值，而这恰恰是 JavaScript 数组在内存中的格式。因此，每次 WebGL 与 JavaScript 运行时之间传递数组时，WebGL 绑定都需要在目标环境分配新数组，以其当前格式迭代数组，然后将数值转型为新数组中的适当格式，而这些要花费很多时间。</p><p>Mozilla 为解决这个问题而实现了 CanvasFloatArray。这是一个提供 JavaScript 接口的、C 语言风格的浮点值数组。JavaScript 运行时使用这个类型可以分配、读取和写入数组。这个数组可以直接传给底层图形驱动程序 API，也可以直接从底层获取到。最终，CanvasFloatArray 变成了 Float32Array，也就是今天定型数组中可用的第一个“类型”。</p><h4 id="3-2-ArrayBuffer"><a href="#3-2-ArrayBuffer" class="headerlink" title="3.2 ArrayBuffer"></a>3.2 ArrayBuffer</h4><p>Float32Array 实际上是一种“视图”，可以允许 JavaScript 运行时访问一块名为 ArrayBuffer 的预分配内存。ArrayBuffer 是所有定型数组及视图引用的基本单位。</p><blockquote><p>  SharedArrayBuffer 是 ArrayBuffer 的一个变体，可以无须复制就在执行上下文间传递它。</p></blockquote><p><code>ArrayBuffer()</code> 是一个普通的 JavaScript 构造函数，可用于在内存中分配特定数量的字节空间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);   <span class="comment">// 在内存中分配 16 字节</span></span><br><span class="line"><span class="title function_">alert</span>(buf.<span class="property">byteLength</span>);            <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>ArrayBuffer 一经创建就不能再调整大小，但可以使用 <code>slice()</code> 复制其全部或部分到一个新实例中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> buf2 = buf1.<span class="title function_">slice</span>(<span class="number">4</span>, <span class="number">12</span>);</span><br><span class="line"><span class="title function_">alert</span>(buf2.<span class="property">byteLength</span>);   <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p>ArrayBuffer 某种程度上类似于 C++ 的 <code>malloc()</code>，但也有几个明显的区别：</p><ul><li><code>malloc()</code> 在分配失败时会返回一个 <code>null</code> 指针，ArrayBuffer 在分配失败时会抛出错误。</li><li><code>malloc()</code> 可利用虚拟内存，最大可分配尺寸只受可寻址系统内存限制，ArrayBuffer 分配内存不超过 <code>Number.MAX_SAFE_INTEGER</code>，即 $2^{53}-1$ 字节。</li><li><code>malloc()</code> 调用成功不会初始化实际的地址，声明 ArrayBuffer 则会将所有二进制位初始化为 0。</li><li>通过 <code>malloc()</code> 分配的堆内存除非调用 <code>free()</code> 或程序退出，否则系统不能再使用，而通过声明 ArrayBuffer 分配的堆内存可以被当成垃圾回收，不用手动释放。</li></ul><p>不能仅通过对 ArrayBuffer 的引用就读取或写入其内容。要读取或写入 ArrayBuffer，就必须通过视图。视图有不同的类型，但引用的都是 ArrayBuffer 中存储的二进制数据。</p><h4 id="3-3-DataView"><a href="#3-3-DataView" class="headerlink" title="3.3 DataView"></a>3.3 DataView</h4><p>第一种允许读写 ArrayBuffer的 视图是 DataView。这个视图专为文件 I/O 和网络 I/O 设计，其 API 支持对缓冲数据的高度控制，但相比于其他类型的视图性能也差一些。DataView 对缓冲内容没有任何预设，也不能迭代。</p><p>必须在对已有的 ArrayBuffer 读取或写入时才能创建 DataView 实例。这个实例可以使用全部或部分 ArrayBuffer，且维护着对该缓冲实例的引用，以及视图在缓冲中开始的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// DataView 默认使用整个 ArrayBuffer</span></span><br><span class="line"><span class="keyword">const</span> fullDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">byteOffset</span>);        <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">byteLength</span>);        <span class="comment">// 16</span></span><br><span class="line"><span class="title function_">alert</span>(fullDataView.<span class="property">buffer</span> === buf);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数接收一个可选的字节偏移量和字节长度</span></span><br><span class="line"><span class="comment">//    byteOffset=0 表示视图从缓冲起点开始</span></span><br><span class="line"><span class="comment">//    byteLength=8 限制视图为前8 个字节</span></span><br><span class="line"><span class="keyword">const</span> firstHalfDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">byteOffset</span>);        <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">byteLength</span>);        <span class="comment">// 8</span></span><br><span class="line"><span class="title function_">alert</span>(firstHalfDataView.<span class="property">buffer</span> === buf);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不指定，则 DataView 会使用剩余的缓冲</span></span><br><span class="line"><span class="comment">//    byteOffset=8 表示视图从缓冲的第9 个字节开始</span></span><br><span class="line"><span class="comment">//    byteLength 未指定，默认为剩余缓冲</span></span><br><span class="line"><span class="keyword">const</span> secondHalfDataView = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf, <span class="number">8</span>);</span><br><span class="line"><span class="title function_">alert</span>(secondHalfDataView.<span class="property">byteOffset</span>);       <span class="comment">// 8</span></span><br><span class="line"><span class="title function_">alert</span>(secondHalfDataView.<span class="property">byteLength</span>);       <span class="comment">// 8</span></span><br><span class="line"><span class="title function_">alert</span>(secondHalfDataView.<span class="property">buffer</span> === buf);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>要通过 DataView 读取缓冲，还需要几个组件：</p><ul><li>首先是要读或写的字节偏移量，可以看成 DataView 中的某种“地址”</li><li>DataView 应该使用 ElementType 来实现 JavaScript 的 Number 类型到缓冲内二进制格式的转换</li><li>最后是内存中值的字节序，默认为大端字节序</li></ul><ol><li><p>ElementType</p><p>DataView 对存储在缓冲内的数据类型没有预设，它暴露的 API 强制开发者在读、写时指定一个 ElementType，然后 DataView 就会忠实地为读、写而完成相应的转换。</p><p>ES 6 支持 8 种不同的 ElementType：</p><p>| ElementType | 字节 | 说明                  | 等价的 C 类型    |<br>| —————- | —— | ——————————- | ———————— |<br>| Int8        | 1    | 8 位有符号整数        | <code>signed char</code>    |<br>| Uint8       | 1    | 8 位无符号整数        | <code>unsigned char</code>  |<br>| Int16       | 2    | 16位有符号整数        | <code>short</code>          |<br>| Uint16      | 2    | 16 位无符号整数       | <code>unsigned short</code> |<br>| Int32       | 4    | 32 位有符号整数       | <code>int</code>            |<br>| Uint32      | 4    | 32 位无符号整数       | <code>unsigned int</code>   |<br>| Float32     | 4    | 32 位 IEEE-754 浮点数 | <code>float</code>          |<br>| Float64     | 8    | 64 位 IEEE-754 浮点数 | <code>double</code>         |</p><p>DataView 为上表中的每种类型都暴露了 <code>get</code> 和 <code>set</code> 方法，这些方法使用 byteOffset（字节偏移量）定位要读取或写入值的位置。类型是可以互换使用的，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 说明整个缓冲确实所有二进制位都是 0</span></span><br><span class="line"><span class="comment">// 检查第一个和第二个字符</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>));   <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">1</span>));   <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 检查整个缓冲</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt16</span>(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 将整个缓冲都设置为 1</span></span><br><span class="line"><span class="comment">// 255 的二进制表示是 11111111</span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"><span class="comment">// DataView 会自动将数据转换为特定的 ElementType</span></span><br><span class="line"><span class="comment">// 255 的十六进制表示是 0xFF</span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">1</span>, <span class="number">0xFF</span>);</span><br><span class="line"><span class="comment">// 现在，缓冲里都是 1 了</span></span><br><span class="line"><span class="comment">// 如果把它当成二补数的有符号整数，则应该是 -1</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt16</span>(<span class="number">0</span>)); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure></li><li><p>字节序</p><p>前面例子中的缓冲有意回避了字节序的问题。“字节序”指的是计算系统维护的一种字节顺序的约定。DataView 只支持两种约定：大端字节序和小端字节序。大端字节序也称为“网络字节序”，意思是最高有效位保存在第一个字节，而最低有效位保存在最后一个字节。小端字节序正好相反，即最低有效位保存在第一个字节，最高有效位保存在最后一个字节。</p><p>JavaScript 运行时所在系统的原生字节序决定了如何读取或写入字节，但 DataView 并不遵守这个约定。对一段内存而言，DataView 是一个中立接口，它会遵循你指定的字节序。DataView 的所有 API 方法都以大端字节序作为默认值，但接收一个可选的布尔值参数，设置为 <code>true</code> 即可启用小端字节序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在内存中分配两个字节并声明一个 DataView</span></span><br><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 填充缓冲，让第一位和最后一位都是 1</span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">0</span>, <span class="number">0x80</span>); <span class="comment">// 设置最左边的位等于1</span></span><br><span class="line">view.<span class="title function_">setUint8</span>(<span class="number">1</span>, <span class="number">0x01</span>); <span class="comment">// 设置最右边的位等于1</span></span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x8   0x0   0x0   0x1</span></span><br><span class="line"><span class="comment">// 1000000000000001</span></span><br><span class="line"><span class="comment">// 按大端字节序读取Uint16</span></span><br><span class="line"><span class="comment">// 0x80 是高字节，0x01 是低字节</span></span><br><span class="line"><span class="comment">// 0x8001 = 2^15 + 2^0 = 32768 + 1 = 32769</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint16</span>(<span class="number">0</span>)); <span class="comment">// 32769</span></span><br><span class="line"><span class="comment">// 按小端字节序读取Uint16</span></span><br><span class="line"><span class="comment">// 0x01 是高字节，0x80 是低字节</span></span><br><span class="line"><span class="comment">// 0x0180 = 2^8 + 2^7 = 256 + 128 = 384</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint16</span>(<span class="number">0</span>, <span class="literal">true</span>)); <span class="comment">// 384</span></span><br><span class="line"><span class="comment">// 按大端字节序写入Uint16</span></span><br><span class="line">view.<span class="title function_">setUint16</span>(<span class="number">0</span>, <span class="number">0x0004</span>);</span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0   0x0   0x0   0x4</span></span><br><span class="line"><span class="comment">// 0000000000000100</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 按小端字节序写入Uint16</span></span><br><span class="line">view.<span class="title function_">setUint16</span>(<span class="number">0</span>, <span class="number">0x0002</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 缓冲内容（为方便阅读，人为加了空格）</span></span><br><span class="line"><span class="comment">// 0x0   0x2   0x0   0x0</span></span><br><span class="line"><span class="comment">// 0000001000000000</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">0</span>)); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getUint8</span>(<span class="number">1</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p>边界情形</p><p>DataView 完成读、写操作的前提是必须有充足的缓冲区，否则就会抛出 RangeError：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line"><span class="comment">// 尝试读取部分超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 尝试读取超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">getInt32</span>(-<span class="number">1</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="comment">// 尝试写入超出缓冲范围的值</span></span><br><span class="line">view.<span class="title function_">setInt32</span>(<span class="number">4</span>, <span class="number">123</span>);</span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure><p>DataView 在写入缓冲里会尽最大努力把一个值转换为适当的类型，后备为 0。如果无法转换，则抛出错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> view = <span class="keyword">new</span> <span class="title class_">DataView</span>(buf);</span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="number">1.5</span>);</span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 1</span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, [<span class="number">4</span>]);</span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 4</span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="string">&#x27;f&#x27;</span>);</span><br><span class="line"><span class="title function_">alert</span>(view.<span class="title function_">getInt8</span>(<span class="number">0</span>)); <span class="comment">// 0</span></span><br><span class="line">view.<span class="title function_">setInt8</span>(<span class="number">0</span>, <span class="title class_">Symbol</span>());</span><br><span class="line"><span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="3-4-定型数组"><a href="#3-4-定型数组" class="headerlink" title="3.4 定型数组"></a>3.4 定型数组</h4>]]></content>
      
      
      <categories>
          
          <category> 《JavaScript高级程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05 基本引用类型</title>
      <link href="/posts/5.html"/>
      <url>/posts/5.html</url>
      
        <content type="html"><![CDATA[<p>引用值（或者对象）是某个特定<strong>引用类型</strong>的实例。虽然从技术上讲 JavaScript 是一门面向对象语言，但 ECMAScript 缺少传统的面向对象编程语言所具备的某些基本结构，包括类和接口。引用类型有时候也被称为<strong>对象定义</strong>，因为它们描述了自己的对象应有的属性和方法。</p><blockquote><p>  注意 引用类型虽然有点像类，但跟类并不是一个概念。</p></blockquote><p>新对象通过使用 <code>new</code> 操作符后跟一个构造函数来创建。构造函数就是用来创建新对象的函数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><p>创建了引用类型 Date 的一个新实例，并将它保存在变量 <code>now</code> 中。<code>Date()</code> 是构造函数，负责创建一个只有默认属性和方法的简单对象。ECMAScript 提供了很多像 Date 这样的原生引用类型，帮助开发者实现常见的任务。</p><blockquote><p>  函数也是一种引用类型。</p></blockquote><h3 id="1-Date"><a href="#1-Date" class="headerlink" title="1. Date"></a>1. Date</h3><p>Date 类型将日期保存为自协调世界时（UTC, Universal Time Coordinated）时间 <code>1970年1月1日零时</code>至今所经过的毫秒数。</p><p>要创建日期对象，就使用 <code>new</code> 操作符来调用 Date 构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><p>在不给 Date 构造函数传参数的情况下，创建的对象将保存当前日期和时间。</p><p>要基于其他日期和时间创建日期对象，必须传入其毫秒（1970年1月1日零时之后的毫秒数）表示。ECMAScript 提供了两个辅助方法：<code>Date.parse()</code> 和 <code>Date.UTC()</code>。</p><p><code>Date.parse()</code> 方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。其支持的日期格式有：</p><ul><li><code>月/日/年</code>，如 <code>5/23/2019</code></li><li><code>月名 日, 年</code>，如 <code>May 23, 2019</code></li><li><code>周几 月名 日 年 时:分:秒 时区</code>，如 <code>Tue May 23 2019 00:00:00 GMT-0700</code></li><li><code>YYYY-MM-DDTHH:mm:ss</code>，如 <code>2019-05-23T00:00:00</code>（只适用于兼容 ES5 的实现）</li></ul><p>如要创建一个表示“2022年7月18日”的日期对象，可使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&quot;July 18, 2022&quot;</span>));</span><br></pre></td></tr></table></figure><p>如果传给 <code>Date.parse()</code> 的字符串并不表示日期，则该方法会返回 <code>NaN</code>。如果直接把表示日期的字符串传给 <code>Date</code> 构造函数，那么 <code>Date</code> 会在后台调用 <code>Date.parse()</code>。即下面代码和前面那行代码等价：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;July 18, 2022&quot;</span>);</span><br></pre></td></tr></table></figure><p><code>Date.UTC()</code> 方法也返回日期的毫秒表示，但参数不同。传给 <code>Date.UTC()</code> 的参数是年、零起点月数（1 月是 0,2 月是 1，以此类推）、日（1-31）、时（0-23）、分、秒和毫秒，只有年和月是必选的。如果不提供日，那么默认为 1 日。其他参数的默认值都是 0。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GMT时间2000年1月1日零点</span></span><br><span class="line"><span class="keyword">let</span> y2k = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// GMT时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">UTC</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>));</span><br></pre></td></tr></table></figure><p>与 <code>Date.parse()</code> 一样，<code>Date.UTC()</code> 也会被 Date 构造函数隐式调用，但有一个区别：这种情况下创建的是本地日期，不是 GMT 日期。前面的例子也可写成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地时间2000年1月1日零点</span></span><br><span class="line"><span class="keyword">let</span> y2k = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 本地时间2005年5月5日下午5点55分55秒</span></span><br><span class="line"><span class="keyword">let</span> allFives = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2005</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">55</span>, <span class="number">55</span>);</span><br></pre></td></tr></table></figure><p>ECMAScript 还提供了 <code>Date.now()</code> 方法，返回表示方法执行时日期和时间的毫秒数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 起始时间</span></span><br><span class="line"><span class="keyword">let</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="title function_">doSomething</span>();</span><br><span class="line"><span class="comment">// 结束时间</span></span><br><span class="line"><span class="keyword">let</span> stop = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"></span><br><span class="line">result = stop - start;</span><br></pre></td></tr></table></figure><h4 id="1-1-继承的方法"><a href="#1-1-继承的方法" class="headerlink" title="1.1 继承的方法"></a>1.1 继承的方法</h4><p>与其他类型一样，Date 类型重写了 <code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法。Date 类型的 <code>toLocaleString()</code> 方法返回与浏览器运行的本地环境一致的日期和时间。 <code>toString()</code> 方法通常返回带时区信息的日期和时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2019年2月1日零点</span></span><br><span class="line"><span class="title function_">toLocaleString</span>()的结果: <span class="number">2</span>/<span class="number">1</span>/<span class="number">2019</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> <span class="variable constant_">AM</span></span><br><span class="line"><span class="title function_">toString</span>()的结果: <span class="title class_">Thu</span> <span class="title class_">Feb</span> <span class="number">1</span> <span class="number">2019</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="variable constant_">GMT</span>-<span class="number">0800</span>(<span class="title class_">Pacific</span> <span class="title class_">Standard</span> <span class="title class_">Time</span>)</span><br></pre></td></tr></table></figure><p>现代浏览器在这两个方法的输出上已经趋于一致。</p><p>Date 类型的 <code>valueOf()</code> 方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符可以直接使用它返回的值。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">0</span>, <span class="number">1</span>);     <span class="comment">// 2019年1月1日</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>);     <span class="comment">// 2019年2月1日</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date1 &lt; date2); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date1 &gt; date2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="1-2-日期格式化方法"><a href="#1-2-日期格式化方法" class="headerlink" title="1.2 日期格式化方法"></a>1.2 日期格式化方法</h4><p>Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p><ul><li><p><code>toDateString()</code> 显示日期中的周几、月、日、年（格式特定于实现）</p></li><li><p><code>toTimeString()</code> 显示日期中的时、分、秒和时区（格式特定于实现）</p></li><li><p><code>toLocaleDateString()</code> 显示日期中的周几、月、日、年（格式特定于实现和地区）</p></li><li><p><code>toLocaleTimeString()</code> 显示日期中的时、分、秒（格式特定于实现和地区）</p></li><li><p><code>toUTCString()</code> 显示完整的UTC日期（格式特定于实现）</p></li></ul><blockquote><p>  这些方法的输出与 <code>toLocaleString()</code> 和 <code>toString()</code>一样，会因浏览器而异。因此不能用于在用户界面上一致地显示日期。</p></blockquote><h4 id="1-3-日期-时间组件方法"><a href="#1-3-日期-时间组件方法" class="headerlink" title="1.3 日期/时间组件方法"></a>1.3 日期/时间组件方法</h4><div class="table-container"><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>getTime()</code></td><td>返回日期的毫秒表示，与 <code>valueOf()</code> 相同</td></tr><tr><td><code>setTime(milliseconds)</code></td><td>设置日期的毫秒表示，从而修改整个日期</td></tr><tr><td><code>getFullYear()</code></td><td>返回 4 位数年</td></tr><tr><td><code>getUTCFullYear</code></td><td>返回 UTC 日期的 4 位数年</td></tr><tr><td><code>setFullYear(year)</code></td><td>设置日期的年（4 位数）</td></tr><tr><td><code>setUTCFullYear(year)</code></td><td>设置 UTC 日期的年（4 位数）</td></tr><tr><td><code>getMonth()</code></td><td>返回日期的月（0 为 1 月）</td></tr><tr><td><code>getUTCMonth()</code></td><td>返回 UTC 日期的月（0 为 1 月）</td></tr><tr><td><code>setMonth(month)</code></td><td>设置日期的月（<code>month</code> 为大于 0 的数值，大于 11 加年）</td></tr><tr><td><code>setUTCMonth(month)</code></td><td>设置 UTC 日期的月（<code>month</code> 为大于 0 的数值，大于 11 加年）</td></tr><tr><td><code>getDate()</code></td><td>返回日期中的日（1-31）</td></tr><tr><td><code>getUTCDate()</code></td><td>返回 UTC 日期中的日（1-31）</td></tr><tr><td><code>setDate(date)</code></td><td>设置日期中的日（若 <code>date</code> 大于该月天数，则加月）</td></tr><tr><td><code>setUTCDate(date)</code></td><td>设置 UTC 日期中的日（若 <code>date</code> 大于该月天数，则加月）</td></tr><tr><td><code>getDay()</code></td><td>返回日期中表示周几的数值（0 表示周日）</td></tr><tr><td><code>getUTCDay()</code></td><td>返回 UTC 日期中表示周几的数值（0 表示周日）</td></tr><tr><td><code>getHours()</code></td><td>返回日期中的时（0-23）</td></tr><tr><td><code>getUTCHours()</code></td><td>返回 UTC 日期中的时（0-23）</td></tr><tr><td><code>setHours(hours)</code></td><td>设置日期中的时（如果 <code>hours</code> 大于 23，则加日）</td></tr><tr><td><code>setUTCHours(hours)</code></td><td>设置 UTC 日期中的时（如果 <code>hours</code> 大于 23，则加日）</td></tr><tr><td><code>getMinutes()</code></td><td>返回日期中的分（0-59）</td></tr><tr><td><code>getUTCMinutes()</code></td><td>返回 UTC 日期中的分（0-59）</td></tr><tr><td><code>setMinutes(minutes)</code></td><td>设置日期中的分（如果 <code>minutes</code> 大于 59，则加时）</td></tr><tr><td><code>setUTCMinutes(minutes)</code></td><td>设置 UTC 日期中的分（如果 <code>minutes</code> 大于 59，则加时）</td></tr><tr><td><code>getSeconds()</code></td><td>返回日期中的秒（0-59）</td></tr><tr><td><code>getUTCSeconds()</code></td><td>返回 UTC 日期中的秒（0-59）</td></tr><tr><td><code>setSeconds(seconds)</code></td><td>设置日期中的秒（如果 <code>seconds</code> 大于 59，则加分）</td></tr><tr><td><code>setUTCSeconds(seconds)</code></td><td>设置 UTC 日期中的秒（如果 <code>seconds</code> 大于 59，则加分）</td></tr><tr><td><code>getMilliseconds()</code></td><td>返回日期中的毫秒</td></tr><tr><td><code>getUTCMilliseconds()</code></td><td>返回 UTC 日期中的毫秒</td></tr><tr><td><code>setMilliseconds(milliseconds)</code></td><td>设置日期中的毫秒</td></tr><tr><td><code>setUTCMilliseconds(milliseconds)</code></td><td>设置 UTC 日期中的毫秒</td></tr><tr><td><code>getTimezoneOffset()</code></td><td>返回以分钟计的 UTC 与本地时区的偏移值</td></tr></tbody></table></div><blockquote><p>  表中“UTC 日期”，指的是没有时区偏移（将日期转换为 GMT）时的日期。</p></blockquote><h3 id="2-RegExp"><a href="#2-RegExp" class="headerlink" title="2. RegExp"></a>2. RegExp</h3><p>ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expression = <span class="regexp">/pattern/</span>flags;</span><br></pre></td></tr></table></figure><p>这个正则表达式的 <code>pattern</code> 可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找和反向引用。每个正则表达式可以带零个或多个 <code>flags</code>，用于控制正则表达式的行为。下面给出了表示匹配模式的标记：</p><ul><li><code>g</code>：全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束</li><li><code>i</code>：不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写</li><li><code>m</code>：多行模式，表示查找到一行文本末尾时会继续查找</li><li><code>y</code>：粘附模式，表示只查找从 lastIndex 开始及之后的字符串</li><li><code>u</code>: Unicode 模式，启用 Unicode 匹配</li><li><code>s</code>:元字符 <code>.</code> 匹配任何字符（包括换行符等空白字符）。</li></ul><p>使用不同模式和标记可以创建出各种正则表达式，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配字符串中的所有&quot;at&quot;</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/at/g</span>;</span><br><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br></pre></td></tr></table></figure><p>与其他语言中的正则表达式类似，所有<strong>元字符</strong>在模式中也必须转义，包括：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( [ &#123; \ ^ $ | ) ] &#125; ? ＊ + .</span><br></pre></td></tr></table></figure><p>元字符在正则表达式中都有一种或多种特殊功能，所以要匹配上面这些字符本身，就必须使用反斜杠来转义。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配第一个&quot;[bc]at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"><span class="comment">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br><span class="line"><span class="comment">// 匹配所有&quot;.at&quot;，忽略大小写</span></span><br><span class="line"><span class="keyword">let</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure><p>前面例子中的正则表达式都是使用字面量形式定义的。正则表达式也可以使用 RegExp 构造函数来创建，它接收两个参数：模式字符串和（可选的）标记字符串，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;[bc]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用 RegExp 也可以基于已有的正则表达式实例，并可选择性地修改它们的标记：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re1 = <span class="regexp">/cat/g</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re1);   <span class="comment">// &quot;/cat/g&quot;</span></span><br><span class="line"><span class="keyword">const</span> re2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(re1);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re2);   <span class="comment">// &quot;/cat/g&quot;</span></span><br><span class="line"><span class="keyword">const</span> re3 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(re1, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(re3);   <span class="comment">// &quot;/cat/i&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-1-RegExp实例属性"><a href="#2-1-RegExp实例属性" class="headerlink" title="2.1 RegExp实例属性"></a>2.1 RegExp实例属性</h4><p>每个 RegExp 实例都有下列属性，提供有关模式的各方面信息：</p><ul><li><p><code>global</code>：布尔值，表示是否设置了 <code>g</code> 标记</p></li><li><p><code>ignoreCase</code>：布尔值，表示是否设置了 <code>i</code> 标记</p></li><li><p><code>unicode</code>：布尔值，表示是否设置了 <code>u</code> 标记</p></li><li><p><code>sticky</code>：布尔值，表示是否设置了 <code>y</code> 标记</p></li><li><p><code>lastIndex</code>：整数，表示在源字符串中下一次搜索的开始位置</p></li><li><p><code>multiline</code>：布尔值，表示是否设置了 <code>m</code> 标记</p></li><li><p><code>dotAll</code>：布尔值，表示是否设置了 <code>s</code> 标记</p></li><li><p><code>source</code>：正则表达式的字面量字符串，没有开头和结尾的斜杠</p></li><li><p><code>flags</code>：正则表达式的标记字符串。始终以字面量字符串模式形式返回（没有前后斜杠）</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pattern1 = <span class="regexp">/\[bc\]at/i</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern1.<span class="property">global</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern1.<span class="property">ignoreCase</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern1.<span class="property">multiline</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern1.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern1.<span class="property">source</span>); <span class="comment">// &quot;\[bc\]at&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern1.<span class="property">flags</span>); <span class="comment">// &quot;i&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pattern2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&quot;\\[bc\\]at&quot;</span>, <span class="string">&quot;i&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern2.<span class="property">global</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern2.<span class="property">ignoreCase</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern2.<span class="property">multiline</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern2.<span class="property">lastIndex</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern2.<span class="property">source</span>); <span class="comment">// &quot;\[bc\]at&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern2.<span class="property">flags</span>); <span class="comment">// &quot;i&quot; </span></span><br></pre></td></tr></table></figure><h4 id="2-2-RegExp-实例方法"><a href="#2-2-RegExp-实例方法" class="headerlink" title="2.2 RegExp 实例方法"></a>2.2 RegExp 实例方法</h4><p>RegExp 实例的主要方法是 <code>exec()</code>，主要用于配合捕获组使用。这个方法只接收一个参数，即要应用模式的字符串。如果找到了匹配项，则返回包含第一个匹配信息的数组；如果没找到匹配项，则返回 <code>null</code>。返回的数组是 Array 的实例，但包含两个额外的属性：<code>index</code> 和 <code>input</code>。<code>index</code> 是字符串中匹配模式的起始位置，<code>input</code> 是要查找的字符串。这个数组的第一个元素是匹配整个模式的字符串，其他元素是与表达式中的捕获组匹配的字符串。如果模式中没有捕获组，则数组只包含一个元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;mom and dad and baby&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/mom( and dad( and baby)? )? /gi</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>);    <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">input</span>);    <span class="comment">// &quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]);       <span class="comment">// &quot;mom and dad and baby&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">1</span>]);       <span class="comment">// &quot; and dad and baby&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">2</span>]);       <span class="comment">// &quot; and baby&quot;</span></span><br></pre></td></tr></table></figure><p>如果模式设置了全局标记，则每次调用 <code>exec()</code> 方法会返回一个匹配的信息。如果没有设置全局标记，则无论对同一个字符串调用多少次 <code>exec()</code>，也只会返回第一个匹配的信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> pattern = <span class="regexp">/.at/</span>;</span><br><span class="line"><span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>);        <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]);           <span class="comment">// cat</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);    <span class="comment">// 0</span></span><br><span class="line">matches = pattern.<span class="title function_">exec</span>(text);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>);        <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]);           <span class="comment">// cat</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);    <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果在这个模式上设置了 <code>g</code> 标记，则每次调用 <code>exec()</code> 都会在字符串中向前搜索下一个匹配项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;cat, bat, sat, fat&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> pattern = <span class="regexp">/.at/g</span>;</span><br><span class="line">    <span class="keyword">let</span> matches = pattern.<span class="title function_">exec</span>(text);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>);        <span class="comment">// 0</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]);           <span class="comment">// cat</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);    <span class="comment">// 3</span></span><br><span class="line">    matches = pattern.<span class="title function_">exec</span>(text);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>);        <span class="comment">// 5</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]);           <span class="comment">// bat</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);    <span class="comment">// 8</span></span><br><span class="line">    matches = pattern.<span class="title function_">exec</span>(text);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(matches.<span class="property">index</span>);        <span class="comment">// 10</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(matches[<span class="number">0</span>]);           <span class="comment">// sat</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(pattern.<span class="property">lastIndex</span>);    <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 《JavaScript高级程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04 变量、作用域和内存</title>
      <link href="/posts/4.html"/>
      <url>/posts/4.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-原始值与引用值"><a href="#1-原始值与引用值" class="headerlink" title="1. 原始值与引用值"></a>1. 原始值与引用值</h3><p>ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。</p><p>在把一个值赋给变量时，JavaScript 引擎必须确定这个值是原始值还是引用值。保存原始值的变量是按值访问的，因为我们操作的就是存储在变量中的实际值。</p><p>引用值是保存在内存中的对象。与其他语言不同，JavaScript 不允许直接访问内存位置，因此也就不能直接操作对象所在的内存空间。在操作对象时，实际上操作的是对该对象的引用而非实际的对象本身。为此，保存引用值的变量是按引用访问的。</p><blockquote><p>  在很多语言中，字符串是使用对象表示的，因此被认为是引用类型。ECMAScript 打破了这个惯例。</p></blockquote><h4 id="1-1-动态属性"><a href="#1-1-动态属性" class="headerlink" title="1.1 动态属性"></a>1.1 动态属性</h4><p>原始值和引用值的定义方式很类似，都是创建一个变量，然后给它赋一个值。不过，在变量保存了这个值之后，可以对这个值做什么，则大有不同。对于引用值而言，可以随时添加、修改和删除其属性和方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>) <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><p>原始值不能有属性，尽管尝试给原始值添加属性不会报错。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">name.<span class="property">age</span> = <span class="number">27</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">age</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>原始类型的初始化可以只使用原始字面量形式，如果使用的是 <code>new</code> 关键字，则 JavaScript 会创建一个 Object 类型的实例，但其行为类似原始值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.<span class="property">age</span> = <span class="number">27</span>;</span><br><span class="line">name2.<span class="property">age</span> = <span class="number">26</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name1.<span class="property">age</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name2.<span class="property">age</span>); <span class="comment">// 26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name1); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><h4 id="1-2-复制值"><a href="#1-2-复制值" class="headerlink" title="1.2 复制值"></a>1.2 复制值</h4><p>除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num1;</span><br></pre></td></tr></table></figure><p><code>num1</code> 包含数值 <code>5</code>。当把 <code>num2</code> 初始化为 <code>num1</code> 时，<code>num2</code> 也会得到数值 <code>5</code>。这个值跟存储在 <code>num1</code> 中的 <code>5</code> 是完全独立的，因为它是那个值的副本，两个变量可以独立使用，互不干扰。</p><p>在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里复制的值实际上是一个指针，它指向存储在堆内存中的对象。操作完成后，两个变量实际上指向同一个对象，因此一个对象上面的变化会在另一个对象上反映出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj1.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj2 = obj1;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><h4 id="1-3-传递函数"><a href="#1-3-传递函数" class="headerlink" title="1.3 传递函数"></a>1.3 传递函数</h4><p>ECMAScript 中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addTen</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    num += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">addTen</span>(count);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(count); <span class="comment">// 20</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 证明对象也是值传递</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = <span class="string">&quot;Matt&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="title function_">setName</span>(person);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br></pre></td></tr></table></figure><h4 id="1-4-确定类型"><a href="#1-4-确定类型" class="headerlink" title="1.4 确定类型"></a>1.4 确定类型</h4><p>前面说过，<code>typeof</code> 操作符对于判断原始值的类型很有用，但对引用值的用处不大。我们通常不关心一个值是不是对象，而是想知道它是什么类型的对象。为了解决这个问题，ECMAScript 提供了 <code>instanceof</code> 操作符，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = variable <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure><p>如果变量是给定引用类型的实例，则 <code>instanceof</code> 操作符返回 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">// 判断person是否为对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(colors <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// 判断colors是否为Array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(pattern <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>); <span class="comment">// 判断pattern是否为正则表达式RegExp</span></span><br></pre></td></tr></table></figure><p>按照定义，所有引用值都是 <code>Object</code> 的实例，因此通过 <code>instanceof</code> 操作符检测任何引用值和 <code>Object</code> 构造函数都会返回 <code>true</code>。类似地，如果用 <code>instanceof</code> 检测原始值，则始终会返回 <code>false</code>，因为原始值不是对象。</p><h3 id="2-执行上下文与作用域"><a href="#2-执行上下文与作用域" class="headerlink" title="2. 执行上下文与作用域"></a>2. 执行上下文与作用域</h3><p>执行上下文（简称“上下文”）的概念在 JavaScript 中颇为重要。变量或函数的上下文决定了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它。</p><p>全局上下文是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一样。在浏览器中，全局上下文就是我们常说的 <code>window</code> 对象，因此所有通过 <code>var</code> 定义的全局变量和函数都会成为 <code>window</code> 对象的属性和方法。使用 <code>let</code> 和 <code>const</code> 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义在它上面的所有变量和函数（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。</p><p>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。</p><p>上下文中的代码在执行的时候，会创建变量对象的一个<strong>作用域链</strong>。这个作用域链决定了各级上下文中的代码在访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其<strong>活动对象</strong>用作变量对象。活动对象最初只有一个定义变量：<code>arguments</code>（全局上下文中没有这个变量）。作用域链中的下一个变量对象来自包含上下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；全局上下文的变量对象始终是作用域链的最后一个变量对象。</p><p>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符（如果没有找到标识符，通常会报错）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (color === <span class="string">&quot;blue&quot;</span>) &#123;</span><br><span class="line">        color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeColor</span>();</span><br></pre></td></tr></table></figure><p>函数 <code>changeColor()</code> 的作用域链包含两个对象：一个是它自己的变量对象（局部），另一个是全局上下文的变量对象。这个函数内部之所以能够访问变量 <code>color</code>，就是因为可以在作用域链中找到它。</p><p>局部作用域中定义的变量可用于在局部上下文中替换全局变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> anotherColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">swapColors</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> tempColor = anotherColor;</span><br><span class="line">        anotherColor = color;</span><br><span class="line">        color = tempColor;</span><br><span class="line">        <span class="comment">// 这里可以访问color、anotherColor和tempColor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里可以访问color和anotherColor，但访问不到tempColor</span></span><br><span class="line">    <span class="title function_">swapColors</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问color</span></span><br><span class="line"><span class="title function_">changeColor</span>();</span><br></pre></td></tr></table></figure><h4 id="2-1-作用域链增强"><a href="#2-1-作用域链增强" class="headerlink" title="2.1 作用域链增强"></a>2.1 作用域链增强</h4><p>虽然执行上下文主要有全局上下文和函数上下文两种（<code>eval()</code> 调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象：</p><ul><li><code>try/catch</code> 语句的 <code>catch</code> 块</li><li><code>with</code> 语句</li></ul><p>这两种情况下，都会在作用域链前端添加一个变量对象。对 <code>with</code> 语句来说，会向作用域链前端添加指定的对象；对 <code>catch</code> 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">buildUrl</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> qs = <span class="string">&quot;?debug=true&quot;</span>;</span><br><span class="line">    <span class="keyword">with</span> (location) &#123;</span><br><span class="line">        <span class="keyword">let</span> url = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>with</code> 语句将 <code>location</code> 对象作为上下文，因此 <code>location</code> 会被添加到作用域链前端。</p><h4 id="2-2-变量声明"><a href="#2-2-变量声明" class="headerlink" title="2.2 变量声明"></a>2.2 变量声明</h4><p>ES6 增加了 <code>let</code> 和 <code>const</code> 两个关键字，让这两个关键字超越 <code>var</code> 成为首选。\</p><ol><li><p>使用 <code>var</code> 的函数作用域声明在使用 <code>var</code> 声明变量时，变量会被自动添加到最接近的上下文。在函数中，最接近的上下文就是函数的局部上下文。在 <code>with</code> 语句中，最接近的上下文也是函数上下文。如果变量未经声明就被初始化了，那么它就会自动被添加到全局上下文，如下面的例子所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量时省略var会创建一个全局变量</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    sum = num1 + num2;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 30</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><blockquote><p>  未经声明而初始化变量是 JavaScript 编程中一个非常常见的错误，会导致很多问题。为此，在初始化变量之前一定要先声明变量。在严格模式下，未经声明就初始化变量会报错。</p></blockquote><p><code>var</code> 声明会被拿到函数或全局作用域的顶部，位于作用域中所有代码之前，这个现象叫作<strong>提升</strong>，在前面已经介绍过了。</p></li><li><p>使用 <code>let</code> 的块级作用域声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a没有定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError: b没有定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ReferenceError: c没有定义</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// ReferenceError: d没有定义</span></span><br></pre></td></tr></table></figure><p><code>let</code> 与 <code>var</code> 的另一个不同之处是在同一作用域内不能声明两次。重复的 <code>var</code> 声明会被忽略，而重复的 <code>let</code> 声明会抛出 <code>SyntaxError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> a; <span class="comment">// 不会报错</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> b;</span><br><span class="line">    <span class="keyword">let</span> b; <span class="comment">// SyntaxError: 标识符b已经声明过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>let</code> 的行为非常适合在循环中声明迭代变量。使用 <code>var</code>声明的迭代变量会泄漏到循环外部，这种情况应该避免。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++j) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(j); <span class="comment">// ReferenceError: j没有定义</span></span><br></pre></td></tr></table></figure><p>严格来讲，<code>let</code> 在 JavaScript 运行时中也会被提升，但由于<strong>暂时性死区</strong>的缘故，实际上不能在声明之前使用 <code>let</code> 变量。因此，从写 JavaScript 代码的角度说，<code>let</code> 的提升跟 <code>var</code> 是不一样的。</p></li><li><p>使用 <code>const</code> 的常量声明</p><p>除了 <code>let</code>, ES6 同时还增加了 <code>const</code> 关键字。使用 <code>const</code> 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a; <span class="comment">// SyntaxError: 常量声明时没有初始化</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 3</span></span><br><span class="line">b = <span class="number">4</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br></pre></td></tr></table></figure><p><code>const</code> 除了要遵循以上规则，其他方面与 <code>let</code> 声明是一样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> a = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// ReferenceError: a没有定义</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// ReferenceError: b没有定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// ReferenceError: c没有定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> d = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// ReferenceError: d没有定义</span></span><br></pre></td></tr></table></figure><p><code>const</code> 声明只应用到顶级原语或者对象。换句话说，赋值为对象的 <code>const</code> 变量不能再被重新赋值为其他引用值，但对象的键则不受限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o1 = &#123;&#125;;</span><br><span class="line">o1 = &#123;&#125;; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="keyword">const</span> o2 = &#123;&#125;;</span><br><span class="line">o2.<span class="property">name</span> = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o2.<span class="property">name</span>); <span class="comment">// &#x27;Jack&#x27;</span></span><br></pre></td></tr></table></figure><p>如果想让整个对象都不能修改，可以使用 <code>Object.freeze()</code>，这样再给属性赋值时虽然不会报错，但会静默失败：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o3 = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123;&#125;);</span><br><span class="line">o3.<span class="property">name</span> = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o3.<span class="property">name</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>由于 <code>const</code> 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例都替换成实际的值，而不会通过查询表进行变量查找。</p><blockquote><p>  开发实践表明，如果开发流程并不会因此而受很大影响，就应该尽可能地多使用 <code>const</code> 声明，除非确实需要一个将来会重新赋值的变量。这样可以从根本上保证提前发现重新赋值导致的 bug。</p></blockquote></li><li><p>标识符查找</p><p>当在特定上下文中为读取或写入而引用一个标识符时，必须通过搜索确定这个标识符表示什么。搜索开始于作用域链前端，以给定的名称搜索对应的标识符。如果在局部上下文中找到该标识符，则搜索停止，变量确定；如果没有找到变量名，则继续沿作用域链搜索（作用域链中的对象也有一个原型链，因此搜索可能涉及每个对象的原型链）。这个过程一直持续到搜索至全局上下文的变量对象。如果仍然没有找到标识符，则说明其未声明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getColor</span>()); <span class="comment">// &#x27;blue&#x27;</span></span><br></pre></td></tr></table></figure><p>对这个搜索过程而言，引用局部变量会让搜索自动停止，而不继续搜索下一级变量对象。也就是说，如果局部上下文中有一个同名的标识符，那就不能在该上下文中引用父上下文中的同名标识符，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getColor</span>()); <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure><p>使用块级作用域声明并不会改变搜索流程，但可以给词法层级添加额外的层次：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getColor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> color = <span class="string">&#x27;green&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getColor</span>()); <span class="comment">// &#x27;green&#x27;</span></span><br></pre></td></tr></table></figure><p>在局部变量 <code>color</code> 声明之后的任何代码都无法访问全局变量 <code>color</code>，除非使用完全限定的写法 <code>window.color</code>。</p></li></ol><h3 id="3-垃圾回收"><a href="#3-垃圾回收" class="headerlink" title="3. 垃圾回收"></a>3. 垃圾回收</h3><p>JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。JavaScript 通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行。垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。</p><p>在浏览器的发展史上，用到过两种主要的标记策略：<strong>标记清理</strong>和<strong>引用计数</strong>。</p><h4 id="3-1-标记清理"><a href="#3-1-标记清理" class="headerlink" title="3.1 标记清理"></a>3.1 标记清理</h4><p>JavaScript 最常用的垃圾回收策略是标记清理。当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。</p><p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。</p><p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p><h4 id="3-2-引用计数"><a href="#3-2-引用计数" class="headerlink" title="3.2 引用计数"></a>3.2 引用计数</h4><p>另一种没那么常用的垃圾回收策略是引用计数。其思路是对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。</p><p>引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：<strong>循环引用</strong>。所谓循环引用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">problem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    objectA.<span class="property">someOtherObject</span> = objectB;</span><br><span class="line">    objectB.<span class="property">anotherObject</span> = objectA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objectA</code> 和 <code>objectB</code> 通过各自的属性相互引用，意味着它们的引用数都是 2。在标记清理策略下，这不是问题，因为在函数结束后，这两个对象都不在作用域中。而在引用计数策略下，<code>objectA</code> 和 <code>objectB</code> 在函数结束后还会存在，因为它们的引用数永远不会变成 0。如果函数被多次调用，则会导致大量内存永远不会被释放。为此，Netscape 在 4.0 版放弃了引用计数，转而采用标记清理。事实上，引用计数策略的问题还不止于此。</p><p>在 IE8 及更早版本的IE中，并非所有对象都是原生 JavaScript 对象。BOM 和 DOM 中的对象是 C++ 实现的组件对象模型 (COM) 对象，而 COM 对象使用引用计数实现垃圾回收。因此，即使这些版本 IE 的 JavaScript 引擎使用标记清理，JavaScript 存取的 COM 对象依旧使用引用计数。换句话说，只要涉及 COM 对象，就无法避开循环引用问题。下面这个简单的例子展示了涉及 COM 对象的循环引用问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;some_element&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> myObject = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">myObject.<span class="property">element</span> = element;</span><br><span class="line">element.<span class="property">someObject</span> = myObject;</span><br></pre></td></tr></table></figure><p>这个例子在一个 DOM 对象 <code>element</code> 和一个原生 JavaScript 对象 <code>myObject</code> 之间制造了循环引用。<code>myObject</code> 变量有一个名为 <code>element</code> 的属性指向 DOM 对象 <code>element</code>，而 <code>element</code> 对象有一个 <code>someObject</code> 属性指回 <code>myObject</code> 对象。由于存在循环引用，因此 DOM 元素的内存永远不会被回收，即使它已经被从页面上删除了也是如此。</p><p>为避免类似的循环引用问题，应该在确保不使用的情况下切断原生 JavaScript 对象与 DOM 元素之间的连接。比如，通过以下代码可以清除前面的例子中建立的循环引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObject.<span class="property">element</span> = <span class="literal">null</span>;</span><br><span class="line">element.<span class="property">someObject</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>把变量设置为 <code>null</code> 实际上会切断变量与其之前引用值之间的关系。当下次垃圾回收程序运行时，这些值就会被删除，内存也会被回收。</p><p>为了补救这一点，IE9 把 BOM 和 DOM 对象都改成了 JavaScript 对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象。</p><h4 id="3-3-性能"><a href="#3-3-性能" class="headerlink" title="3.3 性能"></a>3.3 性能</h4><p>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。</p><p>现代垃圾回收程序会基于对 JavaScript 运行时环境的探测来决定何时运行。探测机制因引擎而异，但基本上都是根据已分配对象的大小和数量来判断的。</p><blockquote><p>  在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在 IE 中，<code>window.CollectGarbage()</code> 方法会立即触发垃圾回收。在 Opera 7 及更高版本中，调用 <code>window.opera.collect()</code> 也会启动垃圾回收程序。</p></blockquote><h4 id="3-4-内存管理"><a href="#3-4-内存管理" class="headerlink" title="3.4 内存管理"></a>3.4 内存管理</h4><p>在使用垃圾回收的编程环境中，开发者通常无须关心内存管理。不过，JavaScript 运行在一个内存管理与垃圾回收都很特殊的环境。分配给浏览器的内存通常比分配给桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全考虑，避免运行大量 JavaScript 的网页耗尽系统内存而导致操作系统崩溃。这个内存限制不仅影响变量分配，也影响调用栈以及能够同时在一个线程中执行的语句数量。</p><p>将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，那么把它设置为 <code>null</code>，从而释放其引用。这也可以叫作<strong>解除引用</strong>。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> localPerson = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    localPerson.<span class="property">name</span> = name;</span><br><span class="line">    <span class="keyword">return</span> localPerson; <span class="comment">// 局部变量会自动解除引用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> globalPerson = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line">globalPerson = <span class="literal">null</span>; <span class="comment">// 解除globalPerson对值的引用</span></span><br></pre></td></tr></table></figure><p>解除对一个值的引用并不会自动导致相关内存被回收。解除引用的关键在于确保相关的值已经不在上下文里了，因此它在下次垃圾回收时会被回收。</p><ol><li><p>通过 <code>const</code> 和 <code>let</code> 声明提升性能</p><p>ES6 增加这两个关键字不仅有助于改善代码风格，而且同样有助于改进垃圾回收的过程。因为 <code>const</code> 和 <code>let</code> 都以块（而非函数）为作用域，所以相比于使用 <code>var</code>，使用这两个新关键字可能会更早地让垃圾回收程序介入，尽早回收应该回收的内存。</p></li><li><p>隐藏类和删除操作</p><p>Chrome 是最流行的浏览器，使用 V8 JavaScript 引擎。V8 在将解释后的 JavaScript 代码编译为实际的机器码时会利用“隐藏类”。运行期间，V8 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征。能够共享相同隐藏类的对象性能会更好，V8 会针对这种情况进行优化，但不一定总能够做到。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br></pre></td></tr></table></figure><p>V8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型。假设之后又添加了下面这行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2.<span class="property">author</span> = <span class="string">&#x27;Jake&#x27;</span>;</span><br></pre></td></tr></table></figure><p>此时两个 <code>Article</code> 实例就会对应两个不同的隐藏类。根据这种操作的频率和隐藏类的大小，这有可能对性能产生明显影响。</p><p>当然，解决方案就是避免 JavaScript 的“先创建再补充”式的动态属性赋值，并在构造函数中一次性声明所有属性，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params">opt_author</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">author</span> = opt_author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>(<span class="string">&#x27;Jake&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这样，两个实例基本上就一样了，因此可以共享一个隐藏类，从而带来潜在的性能提升。不过要记住，使用 <code>delete</code> 关键字会导致生成相同的隐藏类片段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">author</span> = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line"><span class="keyword">delete</span> a1.<span class="property">author</span>;</span><br></pre></td></tr></table></figure><p>在代码结束后，即使两个实例使用了同一个构造函数，它们也不再共享一个隐藏类。动态删除属性与动态添加属性导致的后果一样。最佳实践是把不想要的属性设置为 <code>null</code>。这样可以保持隐藏类不变和继续共享，同时也能达到删除引用值供垃圾回收程序回收的效果。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Article</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">title</span> = <span class="string">&#x27;Inauguration Ceremony Features Kazoo Band&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">author</span> = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> <span class="title class_">Article</span>();</span><br><span class="line">a1.<span class="property">author</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>内存泄漏</p><p>在内存有限的设备上，或者在函数会被调用很多次的情况下，内存泄漏可能是个大问题。JavaScript 中的内存泄漏大部分是由不合理的引用导致的。</p><p>意外声明全局变量是最常见但也最容易修复的内存泄漏问题。下面的代码没有使用任何关键字声明变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">setName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    name = <span class="string">&#x27;Jack&#x27;</span>; <span class="comment">// 编译器认为name是一个全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题很容易解决，只要在变量声明前头加上 <code>var</code>、<code>let</code> 或 <code>const</code> 关键字即可，这样变量就会在函数执行完毕后离开作用域。</p><p>定时器也可能会悄悄地导致内存泄漏。下面的代码中，定时器的回调通过闭包引用了外部变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>只要定时器一直运行，回调函数中引用的 <code>name</code> 就会一直占用内存。垃圾回收程序就不会清理外部变量。</p><p>使用 JavaScript 闭包很容易在不知不觉间造成内存泄漏，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">&#x27;Jake&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用 <code>outer()</code> 会导致分配给 <code>name</code> 的内存被泄漏。以上代码执行后创建了一个内部闭包，只要返回的函数存在就不能清理 <code>name</code>，因为闭包一直在引用着它。假如 <code>name</code> 的内容很大，那可能就是个大问题了。</p></li><li><p>静态分配与对象池</p><p>为了提升 JavaScript 性能，最后要考虑的一点往往就是压榨浏览器了。此时，一个关键问题就是如何减少浏览器执行垃圾回收的次数。开发者无法直接控制什么时候开始收集垃圾，但可以间接控制触发垃圾回收的条件。理论上，如果能够合理使用分配的内存，同时避免多余的垃圾回收，那就可以保住因释放内存而损失的性能。</p><p>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行，这样当然会影响性能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addVector</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> resultant = <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    resultant.<span class="property">x</span> = a.<span class="property">x</span> + b.<span class="property">x</span>;</span><br><span class="line">    resultant.<span class="property">y</span> = a.<span class="property">y</span> + b.<span class="property">y</span>;</span><br><span class="line">    <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用这个函数时，会在堆上创建一个新对象，然后修改它，最后再把它返回给调用者。如果这个矢量对象的生命周期很短，那么它会很快失去所有对它的引用，成为可以被回收的值。假如这个矢量加法函数频繁被调用，那么垃圾回收调度程序会发现这里对象更替的速度很快，从而会更频繁地安排垃圾回收。该问题的解决方案是不要动态创建矢量对象，比如可以修改上面的函数，让它使用一个已有的矢量对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addVector</span>(<span class="params">a, b, resultant</span>) &#123;</span><br><span class="line">    resultant.<span class="property">x</span> = a.<span class="property">x</span> + b.<span class="property">x</span>;</span><br><span class="line">    resultant.<span class="property">y</span> = a.<span class="property">y</span> + b.<span class="property">y</span>;</span><br><span class="line">    <span class="keyword">return</span> resultant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这需要在其他地方实例化矢量参数 <code>resultant</code>，但这个函数的行为没有变。那么在哪里创建矢量可以不让垃圾回收调度程序盯上呢？</p><p>一个策略是使用<strong>对象池</strong>。在初始化的某一时刻，可以创建一个对象池，用来管理一组可回收的对象。应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。下面是一个对象池的伪实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vectorPool是已有的对象池</span></span><br><span class="line"><span class="keyword">let</span> v1 = vectorPool.<span class="title function_">allocate</span>();</span><br><span class="line"><span class="keyword">let</span> v2 = vectorPool.<span class="title function_">allocate</span>();</span><br><span class="line"><span class="keyword">let</span> v3 = vectorPool.<span class="title function_">allocate</span>();</span><br><span class="line">v1.<span class="property">x</span> = <span class="number">10</span>;</span><br><span class="line">v1.<span class="property">y</span> = <span class="number">5</span>;</span><br><span class="line">v2.<span class="property">x</span> = -<span class="number">3</span>;</span><br><span class="line">v2.<span class="property">y</span> = -<span class="number">6</span>;</span><br><span class="line"><span class="title function_">addVector</span>(v1, v2, v3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([v3.<span class="property">x</span>, v3.<span class="property">y</span>]); <span class="comment">// [7, -1]</span></span><br><span class="line">vectorPool.<span class="title function_">free</span>(v1);</span><br><span class="line">vectorPool.<span class="title function_">free</span>(v2);</span><br><span class="line">vectorPool.<span class="title function_">free</span>(v3);</span><br><span class="line"><span class="comment">// 如果对象有属性引用了其他对象</span></span><br><span class="line"><span class="comment">// 则这里也需要把这些属性设置为null</span></span><br><span class="line">v1 = <span class="literal">null</span>;</span><br><span class="line">v2 = <span class="literal">null</span>;</span><br><span class="line">v3 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>如果对象池只按需分配矢量（在对象不存在时创建新的，在对象存在时则复用存在的），那么这个实现本质上是一种贪婪算法，有单调增长但为静态的内存。这个对象池必须使用某种结构维护所有对象，数组是比较好的选择。不过，使用数组来实现，必须留意不要招致额外的垃圾回收，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vectorList = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">let</span> vector = <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">vectorList.<span class="title function_">push</span>(vector);</span><br></pre></td></tr></table></figure><p>由于 JavaScript 数组的大小是动态可变的，引擎会删除大小为 100 的数组，再创建一个新的大小为 200 的数组。垃圾回收程序会看到这个删除操作，说不定因此很快就会跑来收一次垃圾。要避免这种动态分配操作，可以在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作。不过，必须事先想好这个数组有多大。</p><blockquote><p>  静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 《JavaScript高级程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03 语法基础（下）</title>
      <link href="/posts/3.html"/>
      <url>/posts/3.html</url>
      
        <content type="html"><![CDATA[<h3 id="5-操作符"><a href="#5-操作符" class="headerlink" title="5. 操作符"></a>5. 操作符</h3><h4 id="5-1-一元操作符"><a href="#5-1-一元操作符" class="headerlink" title="5.1 一元操作符"></a>5.1 一元操作符</h4><p>只操作一个值的操作符叫一元操作符。一元操作符是 ECMAScript 中最简单的操作符。</p><h5 id="5-1-1-递增-递减操作符"><a href="#5-1-1-递增-递减操作符" class="headerlink" title="5.1.1 递增/递减操作符"></a>5.1.1 递增/递减操作符</h5><p>递增和递减操作符直接照搬自 C 语言，但有两个版本：前缀版和后缀版。前缀版就是 <code>++</code>或者 <code>--</code> 位于变量前头，后缀版就是 <code>++</code>或者 <code>--</code> 位于变量后头。前缀版==先自增/减，后运算==，后缀版==先运算，后自增/自减==。</p><p>无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变。（在计算机科学中，这通常被称为具有<strong>副作用</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">let</span> anotherAge = --age + <span class="number">2</span>; <span class="comment">// 先自增，再运算</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 28</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherAge); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> num3 = num1-- + num2; <span class="comment">// 先运算，后自减</span></span><br><span class="line"><span class="keyword">let</span> num4 = num1 + num2;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num3); <span class="comment">// 22</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num4); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>前缀递增和递减在语句中的优先级是相等的，因此会从左到右依次求值。</p><p>这 4 个操作符可以作用于任何值，不限于整数，字符串、布尔值、浮点值，甚至对象都可以。递增和递减操作符遵循如下规则：</p><ul><li>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</li><li>对于字符串，如果不是有效的数值形式，则将变量的值设置为 <code>NaN</code>。变量类型从字符串变成数值。</li><li>对于布尔值，如果是 <code>false</code>，则转换为 <code>0</code> 再应用改变。变量类型从布尔值变成数值。</li><li>对于布尔值，如果是 <code>true</code>，则转换为 <code>1</code> 再应用改变。变量类型从布尔值变成数值。</li><li>对于浮点值，加 <code>1</code> 或减 <code>1</code>。</li><li>如果是对象，则调用其 <code>valueOf()</code> 方法取得可以操作的值。对得到的值应用上述规则。如果是 <code>NaN</code>，则调用 <code>toString()</code> 并再次应用其他规则。变量类型从对象变成数值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1++;   <span class="comment">// 3</span></span><br><span class="line">s2++;   <span class="comment">// NaN</span></span><br><span class="line">b++;    <span class="comment">// 1</span></span><br><span class="line">f--;    <span class="comment">// 0.10000000000000009（浮点数不精确）</span></span><br><span class="line">o--;    <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><h5 id="5-1-2-一元加和减"><a href="#5-1-2-一元加和减" class="headerlink" title="5.1.2 一元加和减"></a>5.1.2 一元加和减</h5><p>一元加由一个加号 <code>+</code> 表示，放在变量前头，对数值没有任何影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = +num;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 25</span></span><br></pre></td></tr></table></figure><p>如果将一元加应用到非数值，则会执行与使用 <code>Number()</code> 转型函数一样的类型转换：布尔值 <code>false</code> 和 <code>true</code> 转换为 <code>0</code> 和 <code>1</code>，字符串根据特殊规则进行解析，对象会调用它们的 <code>valueOf()</code> 和/或 <code>toString()</code> 方法以得到可以转换的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = +s1;   <span class="comment">// 1</span></span><br><span class="line">s2 = +s2;   <span class="comment">// 1.1</span></span><br><span class="line">s3 = +s3;   <span class="comment">// NaN</span></span><br><span class="line">b = +b;     <span class="comment">// 0</span></span><br><span class="line">f = +f;     <span class="comment">// 1.1</span></span><br><span class="line">o = +o;     <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><p>一元减由一个减号 <code>-</code> 表示，放在变量前头，主要用于把数值变成负值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line">num = -num;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// -25</span></span><br></pre></td></tr></table></figure><p>在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;01&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">&quot;1.1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="string">&quot;z&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> f = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">s1 = +s1;   <span class="comment">// -1</span></span><br><span class="line">s2 = +s2;   <span class="comment">// -1.1</span></span><br><span class="line">s3 = +s3;   <span class="comment">// NaN</span></span><br><span class="line">b = +b;     <span class="comment">// 0</span></span><br><span class="line">f = +f;     <span class="comment">// -1.1</span></span><br><span class="line">o = +o;     <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="5-2-位操作符"><a href="#5-2-位操作符" class="headerlink" title="5.2 位操作符"></a>5.2 位操作符</h4><p>ECMAScript 中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因为 64 位整数存储格式是不可见的。有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位，它的值决定了数值其余部分的格式。正值以真正的二进制格式存储，即 31 位中的每一位都代表 2 的幂。如果一个位是空的，则以 0 填充，相当于忽略不计。</p><p>负值以一种称为<strong>补码</strong>的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算得到：</p><ol><li>确定绝对值的二进制表示</li><li>找到数值的反码</li><li>给结果加1</li></ol><blockquote><p>  默认情况下，ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p></blockquote><p>在对 ECMAScript 中的数值应用位操作符时，后台会发生转换：64 位数值会转换为 32 位数值，然后执行位操作，最后再把结果从 32 位转换为 64 位存储起来。整个过程就像处理 32 位数值一样，这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，即特殊值 <code>NaN</code> 和 <code>Infinity</code> 在位操作中都会被当成 <code>0</code> 处理。如果将位操作符应用到非数值，那么首先会使用 <code>Number()</code> 函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值。</p><p>按位非操作符用波浪符 <code>~</code> 表示，作用是按位取反。</p><p>按位与操作符用和号 <code>&amp;</code> 表示，有两个操作数，作用是按位相与。</p><p>按位或操作符用管道符 <code>|</code> 表示，有两个操作数，作用是按位相或。</p><p>按位异或用脱字符 <code>^</code> 表示，有两个操作数，作用是按位异或（对位相同取 0，不同取 1）。</p><p>左移操作符用 <code>&lt;&lt;</code> 表示，会按照指定的位数将数值的所有位向左移动，以 0 填充空位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">2</span>;             <span class="comment">// 等于二进制10</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &lt;&lt; <span class="number">5</span>; <span class="comment">// 等于二进制1000000，即十进制64</span></span><br></pre></td></tr></table></figure><p>有符号右移用 <code>&gt;&gt;</code> 表示，会将数值的所有32位都向右移，同时保留符号（正或负），以符号位填充空位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldValue = <span class="number">64</span>;             <span class="comment">// 等于二进制1000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt; <span class="number">5</span>;<span class="comment">// 等于二进制10，即十进制2</span></span><br></pre></td></tr></table></figure><p>无符号右移用 <code>&gt;&gt;&gt;</code> 表示，会将数值的所有 32 位都向右移，以 0 填充空位。对于正数，无符号右移与有符号右移结果相同。对于负数，有时候差异会非常大。与无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变得非常之大：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letoldValue=-<span class="number">64</span>;               <span class="comment">//等于二进制11111111111111111111111111000000</span></span><br><span class="line"><span class="keyword">let</span> newValue = oldValue &gt;&gt;&gt; <span class="number">5</span>; <span class="comment">// 等于十进制134217726</span></span><br></pre></td></tr></table></figure><h4 id="5-3-布尔操作符"><a href="#5-3-布尔操作符" class="headerlink" title="5.3 布尔操作符"></a>5.3 布尔操作符</h4><h5 id="5-3-1-逻辑非"><a href="#5-3-1-逻辑非" class="headerlink" title="5.3.1 逻辑非"></a>5.3.1 逻辑非</h5><p>逻辑非操作符由一个叹号 <code>!</code> 表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。</p><ul><li>如果操作数是对象，则返回 <code>false</code></li><li>如果操作数是空字符串，则返回 <code>true</code></li><li>如果操作数是非空字符串，则返回 <code>false</code></li><li>如果操作数是数值 0，则返回 <code>true</code></li><li>如果操作数是非 0 数值（包括 <code>Infinity</code>），则返回 <code>false</code></li><li>如果操作数是 <code>null</code>，则返回 <code>true</code></li><li>如果操作数是 <code>NaN</code>，则返回 <code>true</code></li><li>如果操作数是 <code>undefined</code>，则返回 <code>true</code></li></ul><p>同时使用两个叹号 <code>!!</code>，相当于调用了转型函数 <code>Boolean()</code>。</p><h5 id="5-3-2-逻辑与"><a href="#5-3-2-逻辑与" class="headerlink" title="5.3.2 逻辑与"></a>5.3.2 逻辑与</h5><p>逻辑与操作符由两个和号 <code>&amp;&amp;</code> 表示。</p><p>逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：</p><ul><li>如果第一个操作数是对象，则返回第二个操作数</li><li>如果第二个操作数是对象，则只有第一个操作数求值为 <code>true</code> 才会返回该对象</li><li>如果两个操作数都是对象，则返回第二个操作数</li><li>如果有一个操作数是 <code>null</code>，则返回 <code>null</code></li><li>如果有一个操作数是 <code>NaN</code>，则返回 <code>NaN</code></li><li>如果有一个操作数是 <code>undefined</code>，则返回 <code>undefined</code></li></ul><p>逻辑与操作符是一种<strong>短路操作符</strong>，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>; <span class="comment">// someUndeclaredVariable没有声明</span></span><br><span class="line"><span class="keyword">let</span> result = (found &amp;&amp; someUndeclaredVariable); <span class="comment">// 这里会出错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 不会执行这一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found &amp;&amp; someUndeclaredVariable);   <span class="comment">// 不会出错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);   <span class="comment">// 会执行</span></span><br></pre></td></tr></table></figure><h5 id="5-3-3-逻辑或"><a href="#5-3-3-逻辑或" class="headerlink" title="5.3.3 逻辑或"></a>5.3.3 逻辑或</h5><p>逻辑或操作符由两个管道符 <code>||</code>表示。</p><p>与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则：</p><ul><li>如果第一个操作数是对象，则返回第一个操作数</li><li>如果第一个操作数求值为 <code>false</code>，则返回第二个操作数</li><li>如果两个操作数都是对象，则返回第一个操作数</li><li>如果两个操作数都是 <code>null</code>，则返回 <code>null</code></li><li>如果两个操作数都是 <code>NaN</code>，则返回 <code>NaN</code></li><li>如果两个操作数都是 <code>undefined</code>，则返回 <code>undefined</code></li></ul><p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为 <code>true</code>，第二个操作数就不会再被求值了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> found = <span class="literal">false</span>; <span class="comment">// someUndeclaredVariable没有声明</span></span><br><span class="line"><span class="keyword">let</span> result = (found || someUndeclaredVariable); <span class="comment">// 这里会出错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 不会执行这一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> result = (found || someUndeclaredVariable);   <span class="comment">// 不会出错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);   <span class="comment">// 会执行</span></span><br></pre></td></tr></table></figure><h4 id="5-4-乘性操作符"><a href="#5-4-乘性操作符" class="headerlink" title="5.4 乘性操作符"></a>5.4 乘性操作符</h4><p>如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用 <code>Number()</code> 转型函数转换为数值。</p><h5 id="5-4-1-乘法操作符"><a href="#5-4-1-乘法操作符" class="headerlink" title="5.4.1 乘法操作符"></a>5.4.1 乘法操作符</h5><p>乘法操作符由一个星号 <code>*</code>表示，可以用于计算两个数值的乘积。不过，乘法操作符在处理特殊值时也有一些特殊的行为：</p><ul><li>如果操作数都是数值，则执行常规的乘法运算。如果 ECMAScript 不能表示乘积，则返回 <code>Infinity</code> 或 <code>-Infinity</code>。</li><li>如果有任一操作数是 <code>NaN</code>，则返回 <code>NaN</code>。</li><li>如果是 <code>Infinity</code> 乘以 <code>0</code>，则返回 <code>NaN</code>。</li><li>如果是 <code>Infinity</code> 乘以非 0 的有限数值，则根据第二个操作数的符号返回 <code>Infinity</code> 或 <code>-Infinity</code>。</li><li>如果是 <code>Infinity</code> 乘以 <code>Infinity</code>，则返回 <code>Infinity</code>。</li><li>如果有不是数值的操作数，则先在后台用 <code>Number()</code> 将其转换为数值，然后再应用上述规则。</li></ul><h5 id="5-4-2-除法操作符"><a href="#5-4-2-除法操作符" class="headerlink" title="5.4.2 除法操作符"></a>5.4.2 除法操作符</h5><p>除法操作符由一个斜杠 <code>/</code> 表示，用于计算第一个操作数除以第二个操作数的商。跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为：</p><ul><li>如果操作数都是数值，则执行常规的除法运算。如果 ECMAScript 不能表示商，则返回 <code>Infinity</code> 或 <code>-Infinity</code>。</li><li>如果有任一操作数是 <code>NaN</code>，则返回 <code>NaN</code>。</li><li>如果是 <code>Infinity</code> 除以 <code>Infinity</code>，则返回 <code>NaN</code>。</li><li>如果是 <code>0</code> 除以 <code>0</code>，则返回 <code>NaN</code>。</li><li>如果是非 0 的有限值除以 <code>0</code>，则根据第一个操作数的符号返回 <code>Infinity</code> 或 <code>-Infinity</code>。</li><li>如果是 <code>Infinity</code> 除以任何数值，则根据第二个操作数的符号返回 <code>Infinity</code> 或 <code>-Infinity</code>。</li><li>如果有不是数值的操作数，则先在后台用 <code>Number()</code>函数将其转换为数值，然后再应用上述规则。</li></ul><h5 id="5-4-3-取模操作符"><a href="#5-4-3-取模操作符" class="headerlink" title="5.4.3 取模操作符"></a>5.4.3 取模操作符</h5><p>取模（余数）操作符由一个百分比符号 <code>%</code> 表示，与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为：</p><ul><li>如果操作数是数值，则执行常规除法运算，返回余数。</li><li>如果被除数是无限值，除数是有限值，则返回 <code>NaN</code>。</li><li>如果被除数是有限值，除数是 <code>0</code>，则返回 <code>NaN</code>。</li><li>如果是 <code>Infinity</code> 除以 <code>Infinity</code>，则返回 <code>NaN</code>。</li><li>如果被除数是有限值，除数是无限值，则返回被除数。</li><li>如果被除数是 <code>0</code>，除数不是 <code>0</code>，则返回 <code>0</code>。</li><li>如果有不是数值的操作数，则先在后台用 <code>Number()</code> 函数将其转换为数值，然后再应用上述规则。</li></ul><h4 id="5-5-指数操作符"><a href="#5-5-指数操作符" class="headerlink" title="5.5 指数操作符"></a>5.5 指数操作符</h4><p>ECMAScript 7 新增了指数操作符 <code>**</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">3</span>, <span class="number">2</span>)); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> ** <span class="number">2</span>); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">16</span>, <span class="number">0.5</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">16</span> ** <span class="number">0.5</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>指数操作符也有自己的指数赋值操作符 <code>**=</code>，该操作符执行指数运算和结果的赋值操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> squared = <span class="number">3</span>;</span><br><span class="line">squared ＊＊= <span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(squared); <span class="comment">// 9</span></span><br><span class="line"><span class="keyword">let</span> sqrt = <span class="number">16</span>;</span><br><span class="line">sqrt ＊＊= <span class="number">0.5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sqrt); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h4 id="5-6-加性操作符"><a href="#5-6-加性操作符" class="headerlink" title="5.6 加性操作符"></a>5.6 加性操作符</h4><h5 id="5-6-1-加法操作符"><a href="#5-6-1-加法操作符" class="headerlink" title="5.6.1 加法操作符"></a>5.6.1 加法操作符</h5><p>加法操作符 <code>+</code> 用于求两个数的和，如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：</p><ul><li><p>如果有任一操作数是 <code>NaN</code>，则返回 <code>NaN</code></p></li><li><p>如果是 <code>Infinity</code> 加 <code>Infinity</code>，则返回 <code>Infinity</code></p></li><li><p>如果是 <code>-Infinity</code> 加 <code>-Infinity</code>，则返回 <code>-Infinity</code></p></li><li><p>如果是 <code>Infinity</code> 加 <code>-Infinity</code>，则返回 <code>NaN</code></p></li><li><p>如果是 <code>+0</code> 加 <code>+0</code>，则返回 <code>+0</code></p></li><li><p>如果是 <code>-0</code> 加 <code>+0</code>，则返回 <code>+0</code></p></li><li><p>如果是 <code>-0</code> 加 <code>-0</code>，则返回 <code>-0</code></p></li></ul><p>如果有一个操作数是字符串，则要应用如下规则：</p><ul><li>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面</li><li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起</li></ul><p>如果有任一操作数是对象、数值或布尔值，则调用它们的 <code>toString()</code> 方法以获取字符串，然后再应用前面的关于字符串的规则。对于 <code>undefined</code> 和 <code>null</code>，则调用 <code>String()</code> 函数，分别获取 <code>&quot;undefined&quot;</code> 和 <code>&quot;null&quot;</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// &quot;55&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常见的错误</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + num1 + num2;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;The sum of 5 and 10 is 510&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改正</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;The sum of 5 and 10 is &quot;</span> + (num1 + num2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;The sum of 5 and 10 is 15&quot;</span></span><br></pre></td></tr></table></figure><h5 id="5-6-2-减法操作符"><a href="#5-6-2-减法操作符" class="headerlink" title="5.6.2 减法操作符"></a>5.6.2 减法操作符</h5><p>与加法操作符一样，减法操作符也有一组规则用于处理 ECMAScript 中不同类型之间的转换。</p><ul><li>如果两个操作数都是数值，则执行数学减法运算并返回结果。</li><li>如果有任一操作数是 <code>NaN</code>，则返回 <code>NaN</code>。</li><li>如果是 <code>Infinity</code> 减 <code>Infinity</code>，则返回 <code>NaN</code>。</li><li>如果是 <code>-Infinity</code> 减 <code>-Infinity</code> ，则返回NaN。</li><li>如果是 <code>Infinity</code> 减 <code>-Infinity</code>，则返回 <code>Infinity</code>。</li><li>如果是 <code>-Infinity</code> 减 <code>Infinity</code>，则返回 <code>-Infinity</code>。</li><li>如果是 <code>+0</code> 减 <code>+0</code>，则返回 <code>+0</code>。</li><li>如果是 <code>+0</code> 减 <code>-0</code>，则返回 <code>-0</code>。</li><li>如果是 <code>-0</code> 减 <code>-0</code>，则返回 <code>+0</code>。</li><li>如果有任一操作数是字符串、布尔值、<code>null</code> 或 <code>undefined</code>，则先在后台使用 <code>Number()</code> 将其转换为数值，然后再根据前面的规则执行数学运算。</li><li>如果有任一操作数是对象，则调用其 <code>valueOf()</code> 方法取得表示它的数值。如果对象没有 <code>valueOf()</code> 方法，则调用其 <code>toString()</code> 方法，然后再将得到的字符串转换为数值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="number">5</span>- <span class="literal">true</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="title class_">NaN</span> -<span class="number">1</span>;   <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="number">5</span> - <span class="number">3</span>;     <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="number">5</span> - <span class="string">&quot;&quot;</span>;    <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">let</span> result5 = <span class="number">5</span> - <span class="string">&quot;2&quot;</span>;   <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">let</span> result6 = <span class="number">5</span> - <span class="literal">null</span>; <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h4 id="5-7-关系运算符"><a href="#5-7-关系运算符" class="headerlink" title="5.7 关系运算符"></a>5.7 关系运算符</h4><p>关系操作符执行比较两个值的操作，包括小于 <code>&lt;</code>、大于 <code>&gt;</code>、小于等于 <code>&lt;=</code>和大于等于 <code>&gt;=</code>，这几个操作符都返回布尔值。</p><p>与 ECMAScript 中的其他操作符一样，在将它们应用到不同数据类型时也会发生类型转换和其他行为。</p><ul><li>如果操作数都是数值，则执行数值比较。</li><li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li><li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li><li>如果有任一操作数是对象，则调用其 <code>valueOf()</code> 方法，取得结果后再根据前面的规则执行比较。如果没有 <code>valueOf()</code> 操作符，则调用 <code>toString()</code> 方法，取得结果后再根据前面的规则执行比较。</li><li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="string">&quot;Black&quot;</span> &gt; <span class="string">&quot;white&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="string">&quot;23&quot;</span> &lt; <span class="string">&quot;3&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>; <span class="comment">// &quot;a&quot;会转换为NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result3); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 任何关系操作符在涉及比较 NaN 时都返回 false</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="title class_">NaN</span> &lt; <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result4); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result5 = <span class="title class_">NaN</span> &gt;= <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result5); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h4 id="5-8-相等操作符"><a href="#5-8-相等操作符" class="headerlink" title="5.8 相等操作符"></a>5.8 相等操作符</h4><p>ECMAScript 提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换；第二组是全等和不全等，它们在比较之前不执行转换。</p><h5 id="5-8-1-等于和不等于"><a href="#5-8-1-等于和不等于" class="headerlink" title="5.8.1 等于和不等于"></a>5.8.1 等于和不等于</h5><p>ECMAScript 中的等于操作符用 <code>==</code> 表示，如果操作数相等，则会返回 <code>true</code>；不等于操作符用 <code>!=</code> 表示，如果两个操作数不相等，则会返回 <code>true</code>。这两个操作符都会先进行<strong>强制类型转换</strong>再确定操作数是否相等。</p><p>在转换操作数的类型时，相等和不相等操作符遵循如下规则：</p><ul><li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等；<code>false</code> 转换为 <code>0</code>, <code>true</code>转换为 <code>1</code>。</li><li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的 <code>valueOf()</code> 方法取得其原始值，再根据前面的规则进行比较。</li></ul><p>在进行比较时，这两个操作符会遵循如下规则：</p><ul><li><code>null</code> 和 <code>undefined</code> 相等</li><li><code>null</code> 和 <code>undefined</code> 不能转换为其他类型的值再进行比较</li><li>如果有任一操作数是 <code>NaN</code>，则相等操作符返回 <code>false</code>，不相等操作符返回 <code>true</code>。==即使两个操作数都是 <code>NaN</code>，相等操作符也返回 <code>false</code>，因为按照规则，<code>NaN</code> 不等于 <code>NaN</code>==。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 <code>true</code>。否则，两者不相等。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = <span class="literal">null</span> == <span class="literal">undefined</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="string">&quot;NaN&quot;</span> == <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="number">5</span> == <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result4 = <span class="title class_">NaN</span> == <span class="title class_">NaN</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result5 = <span class="title class_">NaN</span> != <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result6 = <span class="literal">false</span> == <span class="number">0</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result7 = <span class="literal">true</span> == <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result8 = <span class="literal">true</span> == <span class="number">2</span>; <span class="comment">// fasle</span></span><br><span class="line"><span class="keyword">let</span> result9 = <span class="literal">undefined</span> == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result10 = <span class="literal">null</span> == <span class="number">0</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result11 = <span class="string">&quot;5&quot;</span> == <span class="number">5</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="5-8-2-全等和不全等"><a href="#5-8-2-全等和不全等" class="headerlink" title="5.8.2 全等和不全等"></a>5.8.2 全等和不全等</h5><p>全等操作符由 <code>===</code> 表示，只有两个操作数在不转换的前提下相等才返回 <code>true</code>，不全等操作符用 <code>!==</code> 表示，只有两个操作数在不转换的前提下不相等才返回 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> == <span class="number">55</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> === <span class="number">55</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = (<span class="string">&quot;55&quot;</span> != <span class="number">55</span>); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">let</span> result2 = (<span class="string">&quot;55&quot;</span> !== <span class="number">55</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>null == undefined</code> 是 <code>true</code>（因为两个值类似），但 <code>null ===undefined</code> 是 <code>false</code>，因为它们不是相同的数据类型。</p><blockquote><p>  由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符，有助于在代码中保持数据类型的完整性。</p></blockquote><h4 id="5-9-条件运算符"><a href="#5-9-条件运算符" class="headerlink" title="5.9 条件运算符"></a>5.9 条件运算符</h4><p>条件操作符语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure><p>如果 <code>boolean_expression</code> 是 <code>true</code>，则赋值 <code>true_value</code>；如果 <code>boolean_expression</code> 是 <code>false</code>，则赋值 <code>false_value</code>。</p><h4 id="5-10-赋值操作符"><a href="#5-10-赋值操作符" class="headerlink" title="5.10 赋值操作符"></a>5.10 赋值操作符</h4><p>简单赋值用 <code>=</code> 表示，将右手边的值赋给左手边的变量。</p><p>每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：</p><ul><li>乘后赋值 <code>＊=</code></li><li>除后赋值 <code>/=</code></li><li>取模后赋值 <code>%=</code></li><li>加后赋值 <code>+=</code></li><li>减后赋值 <code>-=</code></li><li>左移后赋值 <code>&lt;&lt;=</code></li><li>右移后赋值 <code>&gt;&gt;=</code></li><li>无符号右移后赋值 <code>&gt;&gt;&gt;=</code></li></ul><blockquote><p>  这些操作符仅仅是简写语法，使用它们不会提升性能。</p></blockquote><h4 id="5-11-逗号操作符"><a href="#5-11-逗号操作符" class="headerlink" title="5.11 逗号操作符"></a>5.11 逗号操作符</h4><p>逗号操作符可以用来在一条语句中执行多个操作，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">1</span>, num2 = <span class="number">2</span>, num3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = (<span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="6-语句"><a href="#6-语句" class="headerlink" title="6. 语句"></a>6. 语句</h3><h4 id="6-1-if语句"><a href="#6-1-if语句" class="headerlink" title="6.1 if语句"></a>6.1 if语句</h4><p><code>if</code> 语句是使用最频繁的语句之一，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) statement1 <span class="keyword">else</span> statement2</span><br></pre></td></tr></table></figure><p><code>condition</code> 可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自动调用 <code>Boolean()</code> 函数将这个表达式的值转换为布尔值。如果条件求值为 <code>true</code>，则执行语句 <code>statement1</code>；如果条件求值为 <code>false</code>，则执行语句 <code>statement2</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greater than 25.&quot;</span>); <span class="comment">// 只有一行代码的语句</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Less than or equal to 25.&quot;</span>); <span class="comment">// 一个语句块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以连续使用多个 <code>if</code> 语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) statement1 <span class="keyword">else</span> <span class="keyword">if</span> (condition2) statement2 <span class="keyword">else</span> statement3</span><br></pre></td></tr></table></figure><p>举例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greater than 25.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Between 0 and 25, inclusive.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-do-while语句"><a href="#6-2-do-while语句" class="headerlink" title="6.2 do-while语句"></a>6.2 do-while语句</h4><p><code>do-while</code> 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句话说，循环体内的代码至少执行一次。<code>do-while</code> 的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure><h4 id="6-3-while语句"><a href="#6-3-while语句" class="headerlink" title="6.3 while语句"></a>6.3 while语句</h4><p><code>while</code> 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，<code>while</code> 循环体内的代码有可能不会执行。<code>while</code>循环的语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) statement</span><br></pre></td></tr></table></figure><h4 id="6-4-for语句"><a href="#6-4-for语句" class="headerlink" title="6.4 for语句"></a>6.4 for语句</h4><p><code>for</code> 语句也是先测试语句，只不过增加了进入循环之前的初始化代码，以及循环执行后要执行的表达式，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; expression; post-loop-expression) &#123;</span><br><span class="line">    statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>for</code> 循环的初始化代码中，其实是可以不使用变量声明关键字的。不过，初始化定义的迭代器变量在循环执行完成后几乎不可能再用到了。因此，最清晰的写法是使用 <code>let</code> 声明迭代器变量，这样就可以将这个变量的作用域限定在循环中。</p><p>初始化、条件表达式和循环后表达式都不是必需的。下面这种写法可以创建一个无穷循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">    <span class="title function_">doSomething</span>(;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果只包含条件表达式，那么 <code>for</code> 循环实际上就变成了 <code>while</code> 循环。</p><h4 id="6-5-for-in语句"><a href="#6-5-for-in语句" class="headerlink" title="6.5 for-in语句"></a>6.5 for-in语句</h4><p><code>for-in</code> 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">in</span> expression) statement</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>. <span class="title function_">write</span>(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子使用 <code>for-in</code> 循环显示了 BOM 对象 <code>window</code> 的所有属性。每次执行循环，都会给变量 <code>propName</code> 赋予一个 <code>window</code> 对象的属性作为值，直到 <code>window</code> 的所有属性都被枚举一遍。与 <code>for</code> 循环一样，这里控制语句中的 <code>const</code> 也不是必需的。但为了确保这个局部变量不被修改，推荐使用 <code>const</code>。</p><p>ECMAScript 中对象的属性是无序的，因此 <code>for-in</code> 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。</p><p>如果 <code>for-in</code> 循环要迭代的变量是 <code>null</code> 或 <code>undefined</code>，则不执行循环体。</p><h4 id="6-6-for-of语句"><a href="#6-6-for-of语句" class="headerlink" title="6.6 for-of语句"></a>6.6 for-of语句</h4><p><code>for-of</code> 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (property <span class="keyword">of</span> expression) statement</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> el <span class="keyword">of</span> [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">write</span>(el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>for-of</code> 循环会按照可迭代对象的 <code>next()</code> 方法产生值的顺序迭代元素。</p><p>如果尝试迭代的变量不支持迭代，则 <code>for-of</code> 语句会抛出错误。</p><blockquote><p>  ES2018 对 <code>for-of</code> 语句进行了扩展，增加了 <code>for-await-of</code> 循环，以支持生成期约（promise）的异步可迭代对象。</p></blockquote><h4 id="6-7-标签语句"><a href="#6-7-标签语句" class="headerlink" title="6.7 标签语句"></a>6.7 标签语句</h4><p>标签语句用于给语句加标签，语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">label</span>: statement</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">start</span>: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>start</code> 是一个标签，可以在后面通过 <code>break</code> 或 <code>continue</code> 语句引用。标签语句的典型应用场景是嵌套循环。</p><h4 id="6-8-break和continue语句"><a href="#6-8-break和continue语句" class="headerlink" title="6.8 break和continue语句"></a>6.8 break和continue语句</h4><p><code>break</code> 语句用于立即退出循环，强制执行循环后的下一条语句，而 <code>continue</code> 语句也用于立即退出循环，但会再次从循环顶部开始执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// break退出整个循环</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// continue退出本次循环</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><p><code>break</code> 和 <code>continue</code> 都可以与标签语句一起使用，返回代码中特定的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="attr">outermost</span>:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span> outermost;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 55</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="attr">outermost</span>:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> outermost;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure><h4 id="6-9-with语句"><a href="#6-9-with语句" class="headerlink" title="6.9 with语句"></a>6.9 with语句</h4><p><code>with</code> 语句的用途是将代码作用域设置为特定的对象，其语法是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) statement;</span><br></pre></td></tr></table></figure><p>使用 <code>with</code> 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便利，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.<span class="property">search</span>.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.<span class="property">hostname</span>;</span><br><span class="line"><span class="keyword">let</span> url = location.<span class="property">href</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用with语句改写</span></span><br><span class="line"><span class="title function_">with</span>(<span class="params">location</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> qs = search.<span class="title function_">substring</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> hostName = hostname;</span><br><span class="line">    <span class="keyword">let</span> url = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>严格模式不允许使用 <code>with</code> 语句，否则会抛出错误。</p><blockquote><p>  由于 with 语句影响性能且难于调试其中的代码，通常不推荐使用。</p></blockquote><h4 id="6-10-switch语句"><a href="#6-10-switch语句" class="headerlink" title="6.10 switch语句"></a>6.10 switch语句</h4><p>ECMAScript 中 <code>switch</code> 语句跟 C 语言中 <code>switch</code> 语句的语法非常相似，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">value1</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">value2</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">value3</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">value4</span>:</span><br><span class="line">        statement</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的每个 <code>case</code> 相当于：“如果表达式等于后面的值，则执行下面的语句”。<code>break</code> 关键字会导致代码执行跳出 <code>switch</code> 语句。如果没有 <code>break</code>，则代码会继续匹配下一个条件。<code>default</code> 关键字用于在任何条件都没有满足时指定默认执行的语句。</p><p>虽然 <code>switch</code> 语句是从其他语言借鉴过来的，但 ECMAScript 为它赋予了一些独有的特性。首先，switch` 语句可以用于所有数据类型，可以使用字符串甚至对象。其次，条件的值不需要是常量，也可以是变量或表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="string">&quot;hello world&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot; world&quot;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greeting was found.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;goodbye&quot;</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Closing was found.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Unexpected message was found.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> num &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Less than 0.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">10</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Between 0 and 10.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> num &gt; <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">20</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Between 10 and 20.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;More than 20.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>==<code>switch</code> 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型==。</p><h3 id="7-函数"><a href="#7-函数" class="headerlink" title="7. 函数"></a>7. 函数</h3><p>基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">arg0, arg1, ..., argN</span>) &#123;</span><br><span class="line">    statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过函数名来调用函数，要传给函数的参数放在括号里（如果有多个参数，则用逗号隔开）。</p><p>ECMAScript 中的函数不需要指定是否返回值。任何函数在任何时间都可以使用 <code>return</code> 语句来返回函数的值，用法是后跟要返回的值。</p><p>只要碰到 <code>return</code> 语句，函数就会立即停止执行并退出。因此，<code>return</code> 语句后面的代码不会被执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Helloworld&quot;</span>);  <span class="comment">//不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个函数里也可以有多个 <code>return</code> 语句。</p><p><code>return</code> 语句也可以不带返回值。这时候，函数会立即停止执行并返回 <code>undefined</code>。这种用法最常用于提前终止函数执行，并不是为了返回值。</p><blockquote><p>  最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。</p></blockquote><p>严格模式对函数也有一些限制：</p><ul><li><p>函数不能以 <code>eval</code> 或 <code>arguments</code> 作为名称</p></li><li><p>函数的参数不能叫 <code>eval</code> 或 <code>arguments</code></p></li><li><p>两个命名参数不能拥有同一个名称</p></li></ul><p>如果违反上述规则，则会导致语法错误，代码也不会执行。</p>]]></content>
      
      
      <categories>
          
          <category> 《JavaScript高级程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02 语法基础（上）</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h3><ul><li><p>区分大小写</p></li><li><p>标识符</p><p>所谓标识符，就是变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成：</p><ul><li>第一个字符必须是字母、下划线 <code>_</code> 或者美元 <code>$</code>。</li><li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li></ul><p>标识符中的字母可以是扩展 ASCII 中的字母，也可以是 Unicode 的字母字符，一般只推荐使用 ASCII 字母。</p><p>按照惯例，标识符使用驼峰大小写形式，即第一个单词的首字母小写，后面每个单词的首字母大写。</p><blockquote><p>  关键字、保留字、<code>true</code>、<code>false</code> 和 <code>null</code> 不能作为标识符。</p></blockquote></li><li><p>注释</p><p>分为单行注释和块注释：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">块注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>严格模式</p><p>ECMAScript 5 增加了严格模式的概念。严格模式是一种不同的 JavaScript 解析和执行模型，原来版本中的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对整个脚本启用严格模式，在脚本开头加上这一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br></pre></td></tr></table></figure><p>虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持的 JavaScript 引擎看到它都会切换到严格模式。也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span>;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>语句</p><p>ECMAScript 中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = a + b <span class="comment">// 没有分号有效，但不推荐</span></span><br><span class="line"><span class="keyword">let</span> diff = a - b; <span class="comment">// 推荐写法</span></span><br></pre></td></tr></table></figure><ul><li>加分号可以避免一些不必要的语法错误</li><li>加分号便于开发者通过删除空行来压缩代码（如果没有结尾的分号，只删除空行，则会导致语法错误）</li><li>加分号有助于在某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误</li></ul><p>多条语句可以合并到一个 C 语言风格的代码块中。代码块由一个左花括号 <code>&#123;</code> 标识开始，一个右花括号 <code>&#125;</code> 标识结束：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test) &#123;</span><br><span class="line">    test = <span class="literal">false</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>if</code> 之类的控制语句只在执行多条语句时要求必须有代码块。不过，最佳实践是始终在控制语句中使用代码块，即使要执行的只有一条语句，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有效，但不推荐</span></span><br><span class="line"><span class="keyword">if</span> (test)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">if</span> (test) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-关键字和保留字"><a href="#2-关键字和保留字" class="headerlink" title="2. 关键字和保留字"></a>2. 关键字和保留字</h3><p>ECMA-262 第 6 版规定的关键字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span><span class="keyword">case</span><span class="keyword">catch</span><span class="keyword">class</span><span class="title class_">const</span><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">debugger</span><span class="keyword">default</span><span class="keyword">delete</span><span class="keyword">do</span><span class="keyword">else</span><span class="keyword">export</span></span><br><span class="line"><span class="keyword">extends</span><span class="keyword">finally</span><span class="keyword">for</span><span class="keyword">function</span><span class="keyword">if</span><span class="keyword">import</span></span><br><span class="line"><span class="keyword">in</span><span class="keyword">instanceof</span><span class="keyword">new</span><span class="keyword">return</span><span class="variable language_">super</span><span class="keyword">switch</span></span><br><span class="line"><span class="variable language_">this</span><span class="keyword">throw</span><span class="keyword">try</span><span class="keyword">typeof</span><span class="keyword">var</span><span class="keyword">void</span></span><br><span class="line"><span class="keyword">while</span><span class="keyword">with</span><span class="keyword">yield</span></span><br></pre></td></tr></table></figure><p>ECMA-262 第 6 版规定的保留字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 始终保留</span></span><br><span class="line">enum</span><br><span class="line"><span class="comment">// 严格模式下保留</span></span><br><span class="line">implementsinterface<span class="keyword">let</span>packageprotected</span><br><span class="line">privatepublic<span class="keyword">static</span></span><br><span class="line"><span class="comment">// 模块代码中保留</span></span><br><span class="line"><span class="keyword">await</span></span><br></pre></td></tr></table></figure><p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字和保留字作为标识符和属性名，以确保兼容过去和未来的 ECMAScript 版本。</p><h3 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h3><p>ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量：<code>var</code>、<code>const</code> 和 <code>let</code>。其中，<code>var</code> 在 ECMAScript 的所有版本中都可以使用，而 <code>const</code> 和 <code>let</code> 只能在 ECMAScript 6 及更晚的版本中使用。</p><h4 id="3-1-var关键字"><a href="#3-1-var关键字" class="headerlink" title="3.1 var关键字"></a>3.1 <code>var</code>关键字</h4><p>定义变量可以使用 <code>var</code> 关键字，后跟变量名：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br></pre></td></tr></table></figure><p>不初始化的情况下，变量会保存一个特殊值 <code>undefined</code>。</p><p>可以同是定义一个变量并赋值，即变量初始化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br></pre></td></tr></table></figure><p>变量不仅可以修改值，还可以修改类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">message = <span class="number">100</span>; <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure><h5 id="3-1-1-var声明作用域"><a href="#3-1-1-var声明作用域" class="headerlink" title="3.1.1 var声明作用域"></a>3.1.1 <code>var</code>声明作用域</h5><p>使用 <code>var</code> 操作符定义的变量会成为包含它的函数的局部变量。比如，使用 <code>var</code> 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure><p>在函数内定义变量时省略 <code>var</code> 操作符，可以创建一个全局变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    message = <span class="string">&quot;hi&quot;</span>; <span class="comment">// 全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// &quot;hi&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>  虽然可以通过省略 <code>var</code> 定义全局变量，但不推荐。在局部作用域中定义的全局变量很难维护，也会造成困惑。在严格模式下，给未声明的变量赋值，则会导致抛出 <code>ReferenceError</code>。</p></blockquote><p>如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量（及可选的初始化）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&quot;hi&quot;</span>,</span><br><span class="line">    found = <span class="literal">false</span>,</span><br><span class="line">    age = <span class="number">18</span>;</span><br></pre></td></tr></table></figure><p>在严格模式下，不能定义名为 <code>eval</code> 和 <code>arguments</code> 的变量，否则会导致语法错误。</p><h5 id="3-1-2-var声明提升"><a href="#3-1-2-var声明提升" class="headerlink" title="3.1.2 var声明提升"></a>3.1.2 <code>var</code>声明提升</h5><p>使用 <code>var</code> 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span>; <span class="comment">// 声明会提升，但赋值不会</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> age;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">    age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>反复多次使用 <code>var</code> 声明同一个变量不会出现问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">36</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 36</span></span><br></pre></td></tr></table></figure><h4 id="3-2-let声明"><a href="#3-2-let声明" class="headerlink" title="3.2 let声明"></a>3.2 <code>let</code>声明</h4><p><code>let</code> 跟 <code>var</code> 的作用差不多，但有着非常重要的区别。最明显的区别是，<code>let</code> 声明的范围是块作用域，而 <code>var</code> 声明的范围是函数作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// ReferenceError: age没有定义</span></span><br></pre></td></tr></table></figure><p>块作用域是函数作用域的子集，因此适用于 <code>var</code> 的作用域限制同样也适用于 <code>let</code>。</p><p><code>let</code> 不允许同一个块作用域中出现冗余声明，这样会导致报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">let</span> age; <span class="comment">// SyntaxError: 标识符age已经声明过了</span></span><br></pre></td></tr></table></figure><p>JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标识符不会报错，因为在同一个块中没有重复声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &#x27;Nicholas&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">30</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="number">26</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对声明冗余报错不会因混用 <code>let</code> 和 <code>var</code> 而受影响。这两个关键字声明的并不是不同类型的变量，它们只是指出变量在相关作用域如何存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br><span class="line"><span class="keyword">let</span> name; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="keyword">let</span> age;</span><br><span class="line"><span class="keyword">var</span> age; <span class="comment">// SyntaxError</span></span><br></pre></td></tr></table></figure><h5 id="3-2-1-暂时性死区"><a href="#3-2-1-暂时性死区" class="headerlink" title="3.2.1 暂时性死区"></a>3.2.1 暂时性死区</h5><p><code>let</code> 与 <code>var</code> 的另一个重要的区别，就是 <code>let</code> 声明的变量不会在作用域中被提升。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name会被提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="comment">// age不会被提升</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// ReferenceError: age没有定义</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br></pre></td></tr></table></figure><p>在 <code>let</code> 声明之前的执行瞬间被称为<strong>暂时性死区</strong>（temporal dead zone），在此阶段引用任何后面才声明的变量都会抛出 <code>ReferenceError</code>。</p><h5 id="3-2-2-全局声明"><a href="#3-2-2-全局声明" class="headerlink" title="3.2.2 全局声明"></a>3.2.2 全局声明</h5><p>与 <code>var</code> 关键字不同，使用 <code>let</code> 在全局作用域中声明的变量不会成为 <code>window</code> 对象的属性（<code>var</code> 声明的变量则会）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">name</span>); <span class="comment">// &#x27;Matt&#x27;</span></span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">age</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>为了避免 <code>SyntaxError</code>，必须确保页面不会重复声明同一个变量。</p><h5 id="3-2-3-条件声明"><a href="#3-2-3-条件声明" class="headerlink" title="3.2.3 条件声明"></a>3.2.3 条件声明</h5><p>在使用 <code>var</code> 声明变量时，由于声明会被提升，JavaScript 引擎会自动将多余的声明在作用域顶部合并为一个声明。因为 <code>let</code> 的作用域是块，所以不可能检查前面是否已经使用 <code>let</code> 声明过同名变量，同时也就不可能在没有声明的情况下声明它。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> age = <span class="number">26</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 那它可以假设没有声明过</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 这里没问题，因为可以被作为一个提升声明来处理</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 不需要检查之前是否声明过同名变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> age = <span class="number">36</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 如果age之前声明过，这里会报错</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>try/catch</code> 语句或 <code>typeof</code> 操作符也不能解决，因为条件块中 <code>let</code> 声明的作用域仅限于该块。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">let</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> age = <span class="number">36</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// 假设脚本不确定页面中是否已经声明了同名变量</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 那它可以假设没有声明过</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> name;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// name被限制在if&#123;&#125;块的作用域内</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 因此这个赋值形同全局赋值</span></span></span><br><span class="line"><span class="language-javascript">    name = <span class="string">&#x27;Matt&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 如果age没有声明过，则会报错</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">catch</span>(error) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">let</span> age;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// age被限制在catch&#123;&#125;块的作用域内</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 因此这个赋值形同全局赋值</span></span></span><br><span class="line"><span class="language-javascript">    age = <span class="number">26</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此，对于 <code>let</code> 这个新的 ES6 声明关键字，不能依赖条件声明模式。</p><h5 id="3-2-4-for循环中的let声明"><a href="#3-2-4-for循环中的let声明" class="headerlink" title="3.2.4 for循环中的let声明"></a>3.2.4 <code>for</code>循环中的<code>let</code>声明</h5><p>在 <code>let</code> 出现之前，<code>for</code> 循环定义的迭代变量会渗透到循环体外部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>使用 <code>let</code> 之后，这个问题就消失了，因为迭代变量的作用域仅限于 <code>for</code> 循环块内部：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 循环逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// // ReferenceError: i没有定义</span></span><br></pre></td></tr></table></figure><p>在使用 <code>var</code> 的时候，最常见的问题就是对迭代变量的奇特声明和修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出5、5、5、5、5</span></span><br></pre></td></tr></table></figure><p>之所以会这样，是因为在退出循环时，迭代变量保存的是导致循环退出的值：5。在之后执行超时逻辑时，所有的 <code>i</code> 都是同一个变量，因而输出的都是同一个最终值。</p><p>而在使用 <code>let</code> 声明迭代变量时，JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。每个 <code>setTimeout</code> 引用的都是不同的变量实例，所以 <code>console.log</code> 输出的是循环执行过程中每个迭代变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(i), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出0、1、2、3、4</span></span><br></pre></td></tr></table></figure><p>这种每次迭代声明一个独立变量实例的行为适用于所有风格的 <code>for</code> 循环，包括 <code>for-in</code> 和 <code>for-of</code> 循环。</p><h4 id="3-3-const声明"><a href="#3-3-const声明" class="headerlink" title="3.3 const声明"></a>3.3 <code>const</code>声明</h4><p><code>const</code> 的行为与 <code>let</code> 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 <code>const</code> 声明的变量会导致运行时错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> age = <span class="number">26</span>;</span><br><span class="line">age = <span class="number">36</span>; <span class="comment">// TypeError: 给常量赋值</span></span><br><span class="line"><span class="comment">// const不允许重复声明</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>; <span class="comment">// SyntaxError</span></span><br><span class="line"><span class="comment">// const声明的作用域也是块</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Matt&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;Nicholas&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// Matt</span></span><br></pre></td></tr></table></figure><p><code>const</code> 声明的限制只适用于它指向的变量的引用，如果 <code>const</code> 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 <code>const</code> 的限制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;Matt&#x27;</span>; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>JavaScript 引擎会为 <code>for</code> 循环中的 <code>let</code> 声明分别创建独立的变量实例，虽然 <code>const</code> 变量跟 <code>let</code> 变量很相似，但是不能用 <code>const</code> 来声明迭代变量（因为迭代变量会自增）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;&#125; <span class="comment">// TypeError: 给常量赋值</span></span><br></pre></td></tr></table></figure><p>如果你只想用 <code>const</code> 声明一个不会被修改的 <code>for</code> 循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对 <code>for-of</code> 和 <code>for-in</code> 循环特别有意义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> j = <span class="number">7</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 7, 7, 7, 7, 7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a, b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure><h4 id="3-4-声明风格和最佳实践"><a href="#3-4-声明风格和最佳实践" class="headerlink" title="3.4 声明风格和最佳实践"></a>3.4 声明风格和最佳实践</h4><ol><li><p>不使用 <code>var</code></p><p>限制自己只使用 <code>let</code> 和 <code>const</code> 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p></li><li><p><code>const</code> 优先，<code>let</code> 次之</p><p>使用 <code>const</code> 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 <code>const</code> 来声明变量，只在提前知道未来会有修改时，再使用 <code>let</code>。</p></li></ol><h3 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4. 数据类型"></a>4. 数据类型</h3><p>ECMAScript 有 6 种简单数据类型（也称为<strong>原始类型</strong>）: <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code> 和 <code>Symbol</code>（ECMAScript 6 新增）。还有一种复杂数据类型叫 <code>Object</code>（对象）。<code>Object</code> 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。</p><h4 id="4-1-typeof操作符"><a href="#4-1-typeof操作符" class="headerlink" title="4.1 typeof操作符"></a>4.1 <code>typeof</code>操作符</h4><p><code>typeof</code> 操作符用来确定任意变量的数据类型。对一个值使用 <code>typeof</code> 操作符会返回下列字符串之一：</p><ul><li><code>undefined</code> 表示值未定义</li><li><code>boolean</code> 表示值为布尔值</li><li><code>string</code> 表示值为字符串</li><li><code>number</code> 表示值为数值</li><li><code>object</code> 表示值为对象（而不是函数）或 <code>null</code>（特殊值 <code>null</code> 被认为是一个对空对象的引用）</li><li><code>function</code> 表示值为函数</li><li><code>symbol</code> 表示值为符号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;some string&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(message)); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">100</span>); <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p><code>typeof</code> 是一个操作符而不是函数，所以不需要参数（但可以使用参数）。</p><h4 id="4-2-Undefined类型"><a href="#4-2-Undefined类型" class="headerlink" title="4.2 Undefined类型"></a>4.2 Undefined类型</h4><p>Undefined 类型只有一个值，就是特殊值 <code>undefined</code>。当使用 <code>var</code> 或 <code>let</code> 声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined</code> 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>任何未经初始化的变量都会取得 <code>undefined</code> 值。</p><p>不要显示地给某个变量赋 <code>undefined</code> 值，增加这个特殊值的目的就是为了正式明确空对象指针 <code>null</code> 和未初始化变量的区别。</p><p>对未声明的变量，只能执行一个有用的操作，就是对它调用 <code>typeof</code>（对未声明的变量调用 <code>delete</code> 也不会报错，但这个操作没有意义，且在严格模式下会抛出错误）。</p><p>在对未初始化的变量调用 <code>typeof</code> 时，返回的结果是 <code>undefined</code>，对未声明的变量调用 <code>typeof</code> 也返回 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> message); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>  即使未初始化的变量会被自动赋予 <code>undefined</code> 值，但仍建议在声明变量的同时进行初始化。这样，当 <code>typeof</code> 返回 <code>undefined</code> 时，就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p></blockquote><p>undefined是一个假值（<code>false</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message;</span><br><span class="line"><span class="keyword">if</span> (message) &#123;</span><br><span class="line">    <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!message) &#123;</span><br><span class="line">    <span class="comment">// 会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (age) &#123;</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-Null类型"><a href="#4-3-Null类型" class="headerlink" title="4.3 Null类型"></a>4.3 Null类型</h4><p>Null 类型同样只有一个值，即特殊值 <code>null</code>。逻辑上讲，<code>null</code> 值表示一个空对象指针，这也是给 <code>typeof</code> 传一个 <code>null</code> 会返回 <code>object</code> 的原因：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> car); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>在定义将来要保存对象值的变量时，建议使用 <code>null</code> 来初始化。这样，只要检查这个变量的值是不是 <code>null</code> 就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (car != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// car是一个对象的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>undefined</code> 值是由 <code>null</code> 值派生而来的，因此 ECMA-262 将它们定义为表面上相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>用等于操作符 <code>==</code> 比较 <code>null</code> 和 <code>undefined</code> 始终返回 <code>true</code> ，这个操作符会为了比较而转换它的操作数。</p><p><code>null</code> 是一个假值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> car = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (car) &#123;</span><br><span class="line">    <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!car) &#123;</span><br><span class="line">    <span class="comment">// 会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-Boolean类型"><a href="#4-4-Boolean类型" class="headerlink" title="4.4 Boolean类型"></a>4.4 Boolean类型</h4><p>Boolean 类型包含两个值：<code>true</code> 和 <code>false</code>。<code>true</code> 不等于 1，<code>false</code> 不等于 0。</p><p>要将一个其他类型的值转换为布尔值，可以调用 <code>Boolean()</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> messageAsBoolean = <span class="title class_">Boolean</span>(message);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">转换为<code>true</code>的值</th><th style="text-align:center">转换为<code>false</code>的值</th></tr></thead><tbody><tr><td style="text-align:center">Boolean</td><td style="text-align:center"><code>true</code></td><td style="text-align:center"><code>false</code></td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">非空字符串</td><td style="text-align:center">空字符串</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:center">非零数值（包括无穷值）</td><td style="text-align:center">0，<code>NaN</code></td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">任意对象</td><td style="text-align:center"><code>null</code></td></tr><tr><td style="text-align:center">Undefined</td><td style="text-align:center">N/A（不存在）</td><td style="text-align:center"><code>undefined</code></td></tr></tbody></table></div><h4 id="4-5-Number类型"><a href="#4-5-Number类型" class="headerlink" title="4.5 Number类型"></a>4.5 Number类型</h4><p>Number 类型使用 IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。</p><p>整数可以使用十进制表示，也可以使用八进制（以 <code>0</code> 为前缀）、十六进制（以 <code>0x</code> 为前缀）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> octalNum1 = <span class="number">070</span>; <span class="comment">// 十进制为56</span></span><br><span class="line"><span class="keyword">let</span> octalNum2 = <span class="number">079</span>; <span class="comment">// 无效的八进制，当成十进制的79处理</span></span><br><span class="line"><span class="keyword">let</span> octalNum3 = <span class="number">08</span>; <span class="comment">// 无效的八进制，当成十进制的8处理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制数字中的字母大小写均可</span></span><br><span class="line"><span class="keyword">let</span> hexNum1 = <span class="number">0xA</span>; <span class="comment">// 十进制为10</span></span><br><span class="line"><span class="keyword">let</span> hexNum2 = <span class="number">0x1f</span>; <span class="comment">// 十进制为31</span></span><br></pre></td></tr></table></figure><p>八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。</p><blockquote><p>  ECMAScript 2015 或 ES6 中的八进制值通过前缀 <code>0o</code> 来表示；严格模式下，前缀 <code>0</code> 会被视为语法错误，如果要表示八进制值，应该使用前缀 <code>0o</code>。</p></blockquote><p>使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p><blockquote><p>  由于 JavaScript 保存数值的方式，实际中可能存在正零（+0）和负零（-0），两者在所有情况下都被认为是等同的。</p></blockquote><h5 id="4-5-1-浮点值"><a href="#4-5-1-浮点值" class="headerlink" title="4.5.1 浮点值"></a>4.5.1 浮点值</h5><p>要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">.1</span>; <span class="comment">// 有效，但不推荐</span></span><br></pre></td></tr></table></figure><p>因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字或小数点后面跟着0（如1.0）的情况下，会被转换为整数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum1 = <span class="number">1.</span>; <span class="comment">// 当成整数1处理</span></span><br><span class="line"><span class="keyword">let</span> floatNum2 = <span class="number">10.0</span>; <span class="comment">// 当成整数10处理</span></span><br></pre></td></tr></table></figure><p>对于非常大或非常小的数值，浮点值可以用科学记数法来表示。ECMAScript 中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母 <code>e</code>，再加上一个要乘的10的多少次幂。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> floatNum = <span class="number">3.125e7</span>; <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure><p>默认情况下，ECMAScript 会将小数点后至少包含 6 个零的浮点值转换为科学记数法。</p><p>浮点数存在精度问题，很容易出错，不要将浮点数做相等比较。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">0.3</span>) &#123; <span class="comment">// 不要这么做</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;You got 0.3.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-5-2-值的范围"><a href="#4-5-2-值的范围" class="headerlink" title="4.5.2 值的范围"></a>4.5.2 值的范围</h5><p>ECMAScript 可以表示的最小数值保存在 <code>Number.MIN_VALUE</code> 中，这个值在多数浏览器中是 <code>5e-324</code>；可以表示的最大数值保存在 <code>Number.MAX_VALUE</code> 中，这个值在多数浏览器中是 <code>1.7976931348623157e+308</code>。如果某个计算得到的数值结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity（无穷）值。任何无法表示的负数以 <code>-Infinity</code> 表示，任何无法表示的正数以 <code>Infinity</code> `表示。</p><p>要确定一个值是不是有限大，可以使用 <code>isFinite()</code> 函数，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span> + <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isFinite</span>(result)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>使用 <code>Number.NEGATIVE_INFINITY</code> 和 <code>Number.POSITIVE_INFINITY</code> 也可以获取正、负 Infinity。没错，这两个属性包含的值分别就是 <code>-Infinity</code> 和 <code>Infinity</code>。</p><h5 id="4-5-3-NaN"><a href="#4-5-3-NaN" class="headerlink" title="4.5.3 NaN"></a>4.5.3 NaN</h5><p>有一个特殊的数值叫 <code>NaN</code>，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，在 ECMAScript 中，<code>0</code>、<code>+0</code> 或 <code>-0</code> 相除会返回 <code>NaN</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> / <span class="number">0</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(-<span class="number">0</span> / +<span class="number">0</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p>如果分子是非 0 值，分母是有符号 0 或无符号 0，则会返回 <code>Infinity</code>或 <code>-Infinity</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> / <span class="number">0</span>); <span class="comment">// Infinity</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span> / -<span class="number">0</span>); <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><p>==任何涉及 <code>NaN</code> 的操作始终返回 <code>NaN</code>==。</p><p><code>NaN</code> 不等于包括 <code>NaN</code> 在内的任何值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>ECMAScript 提供了 <code>isNaN()</code> 函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给 <code>isNaN()</code> 后，该函数<strong>会尝试把它转换为数值</strong>。某些非数值的值可以直接转换成数值，如字符串 <code>&quot;10&quot;</code> 或布尔值。任何不能转换为数值的值都会导致这个函数返回 <code>true</code>。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="number">10</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;10&quot;</span>)); <span class="comment">// false, 可以转换为数值10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="literal">true</span>)); <span class="comment">// false, 可以转换为数值1</span></span><br></pre></td></tr></table></figure><p>首先会调用对象的 <code>valueOf()</code> 方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 <code>toString()</code> 方法，并测试其返回值。</p><h5 id="4-5-4-数值转换"><a href="#4-5-4-数值转换" class="headerlink" title="4.5.4 数值转换"></a>4.5.4 数值转换</h5><p>有 3 个函数可以将非数值转换为数值：<code>Number()</code>、<code>parseInt()</code> 和 <code>parseFloat()</code>。 <code>Number()</code> 是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。</p><p><code>Number()</code>函数基于如下规则转换：</p><ul><li>布尔值，<code>true</code>转换为 1，<code>false</code>转换为 0</li><li>数值，直接返回</li><li><code>null</code>，返回 0</li><li><code>undefined</code>，返回 <code>NaN</code></li><li>字符串应用以下规则：<ul><li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值（忽略前面的零）</li><li>如果字符串包含有效的浮点值格式，则会转换为相应的浮点值（忽略前面的零）</li><li>如果字符串包含有效的十六进制格式，则会转换为与该十六进制值对应的十进制整数值</li><li>如果是空字符串（不包含字符），则返回 0</li><li>如果字符串包含除上述情况之外的其他字符，则返回 <code>NaN</code></li></ul></li><li>对象，调用 <code>valueOf()</code> 方法，并按照上述规则转换返回的值。如果转换结果是 <code>NaN</code>，则调用 <code>toString()</code> 方法，再按照转换字符串的规则转换。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="title class_">Number</span>(<span class="string">&quot;hello world!&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="title class_">Number</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="title class_">Number</span>(<span class="string">&quot;000011&quot;</span>); <span class="comment">// 11</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="title class_">Number</span>(<span class="literal">true</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>用 <code>Number()</code> 函数转换字符串时相对复杂，通常在需要得到整数时优先使用 <code>parseInt()</code> 函数。 <code>parseInt()</code> 函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，<code>parseInt()</code> 立即返回 <code>NaN</code>。这意味着空字符串也会返回 <code>NaN</code>。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</p><p>假设字符串中的第一个字符是数值字符，<code>parseInt()</code> 函数也能识别不同的整数格式（十进制、八进制、十六进制）。如果字符串以 <code>0x</code> 开头，就会被解释为十六进制整数。如果以 <code>0</code>开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>); <span class="comment">// 22</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;70&quot;</span>); <span class="comment">// 70</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xf&quot;</span>); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p><code>parseInt()</code> 也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入 <code>16</code> 作为第二个参数，以便正确解析：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="string">&quot;0xAF&quot;</span>, <span class="number">16</span>); <span class="comment">// 175</span></span><br></pre></td></tr></table></figure><p>如果提供了十六进制参数，那么字符串前面的 <code>0x</code> 可以省掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>); <span class="comment">// 175</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>) <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">16</span>) <span class="comment">// 16</span></span><br></pre></td></tr></table></figure><p>因为不传底数参数相当于让 <code>parseInt()</code> 自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。</p><p><code>parseFloat()</code> 函数的工作方式跟 <code>parseInt()</code> 函数类似，都是从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。第一次出现的小数点有效，但第二次无效，此时字符串的剩余字符都会被忽略。</p><p><code>parseFloat()</code> 函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回 <code>0</code>。因为 <code>parseFloat()</code> 只解析十进制值，因此不能指定底数。</p><p>如果字符串表示整数（没有小数点或者小数点后面只有一个零），则 <code>parseFloat()</code> 返回整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="built_in">parseInt</span>(<span class="string">&quot;22.5&quot;</span>); <span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span><span class="number">.1</span>); <span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">let</span> num5 = <span class="built_in">parseInt</span>(<span class="string">&quot;0908.5&quot;</span>); <span class="comment">// 908.5</span></span><br><span class="line"><span class="keyword">let</span> num6 = <span class="built_in">parseInt</span>(<span class="string">&quot;3.125e7&quot;</span>); <span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure><h4 id="4-6-String类型"><a href="#4-6-String类型" class="headerlink" title="4.6 String类型"></a>4.6 String类型</h4><p>String 数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号 <code>&quot;&quot;</code> 、单引号 <code>&#39;&#39;</code> 或反引号标识。</p><p>跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript 语法中表示字符串的引号没有区别。不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。</p><h5 id="4-6-1-字面量"><a href="#4-6-1-字面量" class="headerlink" title="4.6.1 字面量"></a>4.6.1 字面量</h5><p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如：</p><div class="table-container"><table><thead><tr><th>字面量</th><th>含义</th></tr></thead><tbody><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\t</code></td><td>制表</td></tr><tr><td><code>\b</code></td><td>退格</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\f</code></td><td>换页</td></tr><tr><td><code>\\</code></td><td>反斜杠</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td>\`</td><td>反引号</td></tr><tr><td><code>\xnn</code></td><td>以十六进制编码 <code>nn</code> 表示的字符</td></tr><tr><td><code>\unnnn</code></td><td>以十六进制编码 <code>nnnn</code> 表示的 Unicode 字符</td></tr></tbody></table></div><p>不管转义序列多长，都只表示一个字符。</p><p>字符串的长度可以通过其 <code>length</code> 属性获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&quot;This is the letter sigma: \u03a3.&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text.<span class="property">length</span>); <span class="comment">// 28</span></span><br></pre></td></tr></table></figure><p>这个属性返回字符串中 16 位字符的个数。如果字符串中包含双字节字符，那么 <code>length</code> 属性返回的值可能不是准确的字符数。</p><h5 id="4-6-2-字符串的特点"><a href="#4-6-2-字符串的特点" class="headerlink" title="4.6.2 字符串的特点"></a>4.6.2 字符串的特点</h5><p>ECMAScript 中的字符串是不可变的，一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">lang = lang + <span class="string">&quot;Script&quot;</span>;</span><br></pre></td></tr></table></figure><h5 id="4-6-3-转换为字符串"><a href="#4-6-3-转换为字符串" class="headerlink" title="4.6.3 转换为字符串"></a>4.6.3 转换为字符串</h5><p>有两种方式把一个值转换为字符串。一是使用几乎所有值都有的 <code>toString()</code> 方法，其唯一的用途就是返回当前值的字符串等价物。如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">let</span> ageAsString = age.<span class="title function_">toString</span>(); <span class="comment">// &quot;11&quot;</span></span><br><span class="line"><span class="keyword">let</span> found = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> foundAsString = found.<span class="title function_">toString</span>(); <span class="comment">// &quot;true&quot;</span></span><br></pre></td></tr></table></figure><p><code>toString()</code> 方法可见于数值、布尔值、对象和字符串值（字符串值也有 <code>toString()</code> 方法，只是简单地返回自身的一个副本）。<code>null</code> 和 <code>undefined</code> 值没有 <code>toString()</code> 方法。</p><p>多数情况下，<code>toString()</code> 不接收任何参数。不过，在对数值调用这个方法时，<code>toString()</code> 可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，<code>toString()</code> 返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>()); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">2</span>)); <span class="comment">// &quot;1010&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">8</span>)); <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">10</span>)); <span class="comment">// &quot;10&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">16</span>)); <span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><p>如果不确定一个值是不是 <code>null</code> 或 <code>undefined</code>，可以使用 <code>String()</code> 转型函数，它始终会返回表示相应类型值的字符串。</p><p><code>String()</code> 函数遵循如下规则：</p><ul><li>如果值有 <code>toString()</code> 方法，则调用该方法（不传参数）并返回结果</li><li>如果值是 <code>null</code>，返回 <code>&quot;null&quot;</code></li><li>如果值是 <code>undefined</code>，返回 <code>&quot;undefined&quot;</code></li></ul><blockquote><p>  用加号操作符给一个值加上一个空字符串 <code>&quot;&quot;</code> 也可以将其转换为字符串。</p></blockquote><h5 id="4-6-4-模板字面量"><a href="#4-6-4-模板字面量" class="headerlink" title="4.6.4 模板字面量"></a>4.6.4 模板字面量</h5><p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量（使用反引号）保留换行字符，可以跨行定义字符串：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myMultiLineString = <span class="string">&#x27;first line\nsecond line&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> myMultiLineTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myMultiLineString === myMultiLinetemplateLiteral); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>顾名思义，模板字面量在定义 HTML 模板时特别有用。</p><p>由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串看起来可能会缩进不当：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个模板字面量在换行符之后有25 个空格符</span></span><br><span class="line"><span class="keyword">let</span> myTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">                          second line`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myTemplateLiteral.<span class="property">length</span>); <span class="comment">// 47</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个模板字面量以一个换行符开头</span></span><br><span class="line"><span class="keyword">let</span> secondTemplateLiteral = <span class="string">`</span></span><br><span class="line"><span class="string">first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(secondTemplateLiteral[<span class="number">0</span>] === <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个模板字面量没有意料之外的字符</span></span><br><span class="line"><span class="keyword">let</span> thirdTemplateLiteral = <span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(thirdTemplateLiteral);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure><h5 id="4-6-5-字符串插值"><a href="#4-6-5-字符串插值" class="headerlink" title="4.6.5 字符串插值"></a>4.6.5 字符串插值</h5><p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的 JavaScript 句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p><p>字符串插值通过在 <code>$&#123;&#125;</code> 中使用一个 JavaScript 表达式实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> exponent = <span class="string">&#x27;second&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> interpolatedTemplateLiteral = </span><br><span class="line"><span class="string">`<span class="subst">$&#123; value &#125;</span> to the <span class="subst">$&#123; exponent &#125;</span> power is <span class="subst">$&#123; value ＊ value &#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(interpolatedTemplateLiteral);   <span class="comment">// 5 to the second power is 25</span></span><br></pre></td></tr></table></figure><p>所有插入的值或表达式都会使用 <code>toString()</code> 强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。</p><p>在插值表达式中可以调用函数和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">capitalize</span>(<span class="params">word</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">`<span class="subst">$&#123; word[<span class="number">0</span>].toUpperCase() &#125;</span><span class="subst">$&#123; word.slice(<span class="number">1</span>) &#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123; capitalize(<span class="string">&#x27;hello&#x27;</span>) &#125;</span>, <span class="subst">$&#123; capitalize(<span class="string">&#x27;world&#x27;</span>) &#125;</span>! `</span>); <span class="comment">// Hello, World!</span></span><br></pre></td></tr></table></figure><p>模板也可以插入自己之前的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">append</span>(<span class="params"></span>) &#123;</span><br><span class="line">    value = <span class="string">`<span class="subst">$&#123;value&#125;</span>abc`</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">append</span>();   <span class="comment">// abc</span></span><br><span class="line"><span class="title function_">append</span>();   <span class="comment">// abcabc</span></span><br><span class="line"><span class="title function_">append</span>();   <span class="comment">// abcabcabc</span></span><br></pre></td></tr></table></figure><h5 id="4-6-6-模板字面量标签函数"><a href="#4-6-6-模板字面量标签函数" class="headerlink" title="4.6.6 模板字面量标签函数"></a>4.6.6 模板字面量标签函数</h5><p>模板字面量也支持定义<strong>标签函数</strong>，而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p><p>标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。</p><p>标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">simpleTag</span>(<span class="params">strings, aValExpression, bValExpression, sumExpression</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strings);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(aValExpression);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bValExpression);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sumExpression);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> untaggedResult = <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span>+<span class="subst">$&#123; b &#125;</span>=<span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(untaggedResult);    <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure><p>因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">functionsimpleTag (strings, ...expressions) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(strings);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> expression <span class="keyword">of</span> expressions) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(expression);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foobar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taggedResult = simpleTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// [&quot;&quot;, &quot; + &quot;, &quot; = &quot;, &quot;&quot;]</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(taggedResult); <span class="comment">// &quot;foobar&quot;</span></span><br></pre></td></tr></table></figure><p>对于有 n 个插值的模板字面量，传给标签函数的表达式参数的个数始终是 n，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。因此，如果想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">zipTag</span>(<span class="params">strings, ...expressions</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> strings[<span class="number">0</span>] +</span><br><span class="line">        expressions.<span class="title function_">map</span>(<span class="function">(<span class="params">e, i</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;e&#125;</span><span class="subst">$&#123;strings[i + <span class="number">1</span>]&#125;</span>`</span>)</span><br><span class="line">        .<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> untaggedResult =     <span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="keyword">let</span> taggedResult = zipTag<span class="string">`<span class="subst">$&#123; a &#125;</span> + <span class="subst">$&#123; b &#125;</span> = <span class="subst">$&#123; a + b &#125;</span>`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(untaggedResult); <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(taggedResult);   <span class="comment">// &quot;6 + 9 = 15&quot;</span></span><br></pre></td></tr></table></figure><h5 id="4-6-7-原始字符串"><a href="#4-6-7-原始字符串" class="headerlink" title="4.6.7 原始字符串"></a>4.6.7 原始字符串</h5><p>使用模板字面量也可以直接获取原始的模板字面量内容，而不是被转换后的字符表示。为此，可以使用默认的 <code>String.raw</code> 标签函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unicode示例</span></span><br><span class="line"><span class="comment">// \u00A9 是版权符号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`\u00A9`</span>); <span class="comment">// ©</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`\u00A9`</span>); <span class="comment">// \u00A9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 换行符示例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`first line\nsecond line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`first line\nsecond line`</span>); <span class="comment">// &quot;first line\nsecond line&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对实际的换行符来说是不行的, 它们不会被转换成转义序列的形式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>.<span class="property">raw</span><span class="string">`first line</span></span><br><span class="line"><span class="string">second line`</span>);</span><br><span class="line"><span class="comment">// first line</span></span><br><span class="line"><span class="comment">// second line</span></span><br></pre></td></tr></table></figure><p>也可以通过标签函数的第一个参数，即字符串数组的 <code>.raw</code> 属性取得每个字符串的原始内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">printRaw</span>(<span class="params">strings</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Actual characters:&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> string <span class="keyword">of</span> strings) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(string);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Escaped characters; &#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> rawString <span class="keyword">of</span> strings.<span class="property">raw</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(rawString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printRaw<span class="string">`\u00A9<span class="subst">$&#123; <span class="string">&#x27;and&#x27;</span> &#125;</span>\n`</span>;</span><br><span class="line"><span class="comment">// Actual characters:</span></span><br><span class="line"><span class="comment">// ©</span></span><br><span class="line"><span class="comment">//（换行符）</span></span><br><span class="line"><span class="comment">// Escaped characters:</span></span><br><span class="line"><span class="comment">// \u00A9</span></span><br><span class="line"><span class="comment">// \n</span></span><br></pre></td></tr></table></figure><h4 id="4-7-Symbol类型"><a href="#4-7-Symbol类型" class="headerlink" title="4.7 Symbol类型"></a>4.7 Symbol类型</h4><p>Symbol 是 ECMAScript 6 新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。</p><p>尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p><h5 id="4-7-1-符号的基本用法"><a href="#4-7-1-符号的基本用法" class="headerlink" title="4.7.1 符号的基本用法"></a>4.7.1 符号的基本用法</h5><p>符号需要使用 <code>Symbol()</code> 函数初始化。因为符号本身是原始类型，所以 <code>typeof</code> 操作符对符号返回 <code>symbol</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> sym); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><p>调用 <code>Symbol()</code> 函数时，也可以传入一个字符串参数作为对符号的描述，将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> otherGenericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> otherFooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol == otherFooSymbol); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol == otherFooSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建 <code>Symbol()</code> 实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> genericSymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(genericSymbol);   <span class="comment">// Symbol()</span></span><br><span class="line"><span class="keyword">let</span> fooSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooSymbol); <span class="comment">// Symbol(&#x27;foo&#x27;)</span></span><br></pre></td></tr></table></figure><p><code>Symbol()</code> 函数不能与 <code>new</code> 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myBoolean = <span class="keyword">new</span> <span class="title class_">Boolean</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> myBoolean); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myString = <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> myString); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> myNumber = <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> myNumber); <span class="comment">// &quot;object&quot;</span></span><br><span class="line"><span class="keyword">let</span> mySymbol = <span class="keyword">new</span> <span class="title class_">Symbol</span>(); <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>如果想使用符号包装对象，可以借用 <code>Object()</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> myWrappedSymbol = <span class="title class_">Object</span>(mySymbol);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> myWrappedSymbol); <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure><h5 id="4-7-2-使用全局符号注册表"><a href="#4-7-2-使用全局符号注册表" class="headerlink" title="4.7.2 使用全局符号注册表"></a>4.7.2 使用全局符号注册表</h5><p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。为此，需要使用 <code>Symbol.for()</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fooGlobalSymbol); <span class="comment">// symbol</span></span><br></pre></td></tr></table></figure><p><code>Symbol.for()</code> 对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 创建新符号</span></span><br><span class="line"><span class="keyword">let</span> otherFooGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// 重用已有符号</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fooGlobalSymbol === otherFooGlobalSymbol); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用 <code>Symbol()</code> 定义的符号也并不等同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> localSymbol = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> globalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(localSymbol === globalSymbol); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 <code>Symbol.for()</code> 的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyGlobalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(emptyGlobalSymbol); <span class="comment">// Symbol(undefined)</span></span><br></pre></td></tr></table></figure><p>还可以使用 <code>Symbol.keyFor()</code> 来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建全局符号</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s)); <span class="comment">// foo</span></span><br><span class="line"><span class="comment">// 创建普通符号</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(s2)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如果传给 <code>Symbol.keyFor()</code> 的不是符号，则该方法抛出 <code>TypeError</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(<span class="number">123</span>); <span class="comment">// TypeError: 123 is not a symbol</span></span><br></pre></td></tr></table></figure><h5 id="4-7-3-使用符号作为属性"><a href="#4-7-3-使用符号作为属性" class="headerlink" title="4.7.3 使用符号作为属性"></a>4.7.3 使用符号作为属性</h5><p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和 <code>Object.defineProperty()</code> / <code>Object.defineProperties()</code> 定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>),</span><br><span class="line">    s3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;baz&#x27;</span>),</span><br><span class="line">    s4 = <span class="title class_">Symbol</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    [s1]: <span class="string">&#x27;foo val&#x27;</span></span><br><span class="line">&#125;; <span class="comment">// 这样也可以：o[s1] = &#x27;foo val&#x27;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); <span class="comment">// &#123;Symbol(foo): foo val&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, s2, &#123;<span class="attr">value</span>: <span class="string">&#x27;bar val&#x27;</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); <span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(o, &#123;</span><br><span class="line">    [s3]: &#123;<span class="attr">value</span>: <span class="string">&#x27;baz val&#x27;</span>&#125;,</span><br><span class="line">    [s4]: &#123;<span class="attr">value</span>: <span class="string">&#x27;qux val&#x27;</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o);</span><br><span class="line"><span class="comment">// &#123;Symbol(foo): foo val, Symbol(bar): bar val, Symbol(baz): baz val, Symbol(qux): qux val</span></span><br></pre></td></tr></table></figure><p>类似于 <code>Object.getOwnPropertyNames()</code> 返回对象实例的常规属性数组， <code>Object.getOwnProperty-Symbols()</code> 返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。<code>Object.getOwnProperty-Descriptors()</code> 会返回同时包含常规和符号属性描述符的对象。<code>Reflect.ownKeys()</code> 会返回两种类型的键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>),</span><br><span class="line">    s2 = <span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    [s1]: <span class="string">&#x27;foo val&#x27;</span>,</span><br><span class="line">    [s2]: <span class="string">&#x27;bar val&#x27;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="string">&#x27;baz val&#x27;</span>,</span><br><span class="line">    <span class="attr">qux</span>: <span class="string">&#x27;qux val&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o)); <span class="comment">// [Symbol(foo), Symbol(bar)]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyNames</span>(o)); <span class="comment">// [&quot;baz&quot;, &quot;qux&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(o));</span><br><span class="line"><span class="comment">// &#123;baz: &#123;...&#125;, qux: &#123;...&#125;, Symbol(foo): &#123;...&#125;, Symbol(bar): &#123;...&#125;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">ownKeys</span>(o));</span><br><span class="line"><span class="comment">// [&quot;baz&quot;, &quot;qux&quot;, Symbol(foo), Symbol(bar)]</span></span><br></pre></td></tr></table></figure><p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="string">&#x27;foo&#x27;</span>)]: <span class="string">&#x27;fooval&#x27;</span>,</span><br><span class="line">    [<span class="title class_">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>)]: <span class="string">&#x27;barval&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(o); <span class="comment">// &#123;Symbol(foo): &quot;foo val&quot;, Symbol(bar): &quot;bar val&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> barSymbol = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertySymbols</span>(o).<span class="title function_">find</span>(<span class="function">(<span class="params">symbol</span>) =&gt;</span> symbol.<span class="title function_">toString</span>().<span class="title function_">match</span>(<span class="regexp">/bar/</span>));</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(barSymbol); <span class="comment">// Symbol(bar)</span></span><br></pre></td></tr></table></figure><h5 id="4-7-4-常用内置符号"><a href="#4-7-4-常用内置符号" class="headerlink" title="4.7.4 常用内置符号"></a>4.7.4 常用内置符号</h5><p>ECMAScript 6 也引入了一批常用内置符号，用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。</p><p>这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，<code>`for-of</code> 循环会在相关对象上使用 <code>Symbol.iterator</code> 属性，那么就可以通过在自定义对象上重新定义 <code>Symbol.iterator</code> 的值，来改变 <code>for-of</code> 在迭代该对象时的行为。</p><p>这些内置符号是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p><blockquote><p>  在提到 ECMAScript 规范时，经常会引用符号在规范中的名称，前缀为 <code>@@</code>，如 <code>@@iterator</code> 指的就是 <code>Symbol.iterator</code>。</p></blockquote><h5 id="4-7-5-Symbol-asyncIterator"><a href="#4-7-5-Symbol-asyncIterator" class="headerlink" title="4.7.5 Symbol.asyncIterator"></a>4.7.5 <code>Symbol.asyncIterator</code></h5><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法返回对象默认的 <code>AsyncIterator</code>，由 <code>for-await-of</code> 语句使用”。换句话说，这个符号表示实现异步迭代器 API 的函数。<code>for-await-of</code> 循环会利用这个函数执行异步迭代操作。循环时，会调用以 <code>Symbol.asyncIterator</code> 为键的函数，并期望这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API 的 <code>AsyncGenerator</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">async</span> *[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]()); <span class="comment">// AsyncGenerator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>技术上，这个由 <code>Symbol.asyncIterator</code> 函数生成的对象应该通过其 <code>next()</code> 方法陆续返回 Promise 实例。可以通过显式地调用 <code>next()</code> 方法返回，也可以隐式地通过异步生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Emitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">max</span> = max;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">asyncIdx</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> *[<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">asyncIdx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="variable language_">this</span>.<span class="property">asyncIdx</span>++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> emitter = <span class="keyword">new</span> <span class="title class_">Emitter</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="title function_">await</span>(<span class="params"><span class="keyword">const</span> x <span class="keyword">of</span> emitter</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncCount</span>();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><blockquote><p>  <code>Symbol.asyncIterator</code> 是 ES2018 规范定义的，因此只有版本非常新的浏览器支持它。</p></blockquote><h5 id="4-7-6-Symbol-hasInstance"><a href="#4-7-6-Symbol-hasInstance" class="headerlink" title="4.7.6 Symbol.hasInstance"></a>4.7.6 <code>Symbol.hasInstance</code></h5><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例，由 <code>instanceof</code> 操作符使用”。<code>instanceof</code> 操作符可以用来确定一个对象实例的原型链上是否有原型。<code>instanceof</code> 的典型使用场景如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f <span class="keyword">instanceof</span> <span class="title class_">Foo</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 ES6 中，<code>instanceof</code> 操作符会使用 <code>Symbol.hasInstance</code> 函数来确定关系。以 <code>Symbol.hasInstance</code> 为键的函数会执行同样的操作，只是操作数对调了一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Foo</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](f)); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Bar</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这个属性定义在 Function 的原型上，因此默认在所有函数和类上都可以调用。由于 <code>instanceof</code> 操作符会在原型链上寻找这个属性定义，就跟在原型链上寻找其他属性一样，因此可以在继承的类上通过静态方法重新定义这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Bar</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Baz</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Bar</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Bar</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Baz</span>[<span class="title class_">Symbol</span>.<span class="property">hasInstance</span>](b));  <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b <span class="keyword">instanceof</span> <span class="title class_">Baz</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="4-7-7-Symbol-isConcatSpreadable"><a href="#4-7-7-Symbol-isConcatSpreadable" class="headerlink" title="4.7.7 Symbol.isConcatSpreadable"></a>4.7.7 <code>Symbol.isConcatSpreadable</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个布尔值，如果是 <code>true</code>，则意味着对象应该用 <code>Array.prototype.concat()</code> 打平其数组元素”。</p><p>ES6 中的 <code>Array.prototype.concat()</code> 方法会根据接收到的对象类型选择如何将一个类数组对象拼接成数组实例。覆盖 <code>Symbol.isConcatSpreadable</code> 的值可以修改这个行为。</p><p>数组对象默认情况下会被打平到已有的数组，<code>false</code> 或假值会导致整个对象被追加到数组末尾。类数组对象默认情况下会被追加到数组末尾，<code>true</code> 或真值会导致这个类数组对象被打平到数组实例。其他不是类数组对象的对象在 <code>Symbol.isConcatSpreadable</code> 被设置为 <code>true</code> 的情况下将被忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> initial = [<span class="string">&#x27;foo&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">&#x27;bar&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(array)); <span class="comment">// [&#x27;foo&#x27;, &#x27;bar&#x27;]</span></span><br><span class="line"></span><br><span class="line">array[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(array)); <span class="comment">// [&#x27;foo&#x27;, Array(1)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLikeObject = &#123; <span class="attr">length</span>: <span class="number">1</span>, <span class="number">0</span>: <span class="string">&#x27;baz&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arrayLikeObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(arrayLikeObject)); <span class="comment">// [&#x27;foo&#x27;, &#123;...&#125;]</span></span><br><span class="line"></span><br><span class="line">arrayLikeObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(arrayLikeObject)); <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherObject = <span class="keyword">new</span> <span class="title class_">Set</span>().<span class="title function_">add</span>(<span class="string">&#x27;qux&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(otherObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(otherObject)); <span class="comment">// [&#x27;foo&#x27;, Set(1)]</span></span><br><span class="line">otherObject[<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(initial.<span class="title function_">concat</span>(otherObject)); <span class="comment">// [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure><h5 id="4-7-8-Symbol-iterator"><a href="#4-7-8-Symbol-iterator" class="headerlink" title="4.7.8 Symbol.iterator"></a>4.7.8 <code>Symbol.iterator</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个方法，该方法返回对象默认的迭代器，由 <code>for-of</code> 语句使用”。换句话说，这个符号表示实现迭代器 API 的函数。<code>for-of</code> 循环这样的语言结构会利用这个函数执行迭代操作。循环时，它们会调用以 <code>Symbol.iterator</code> 为键的函数，并默认这个函数会返回一个实现迭代器 API 的对象。很多时候，返回的对象是实现该 API 的 Generator：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    ＊[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()); <span class="comment">// Generator &#123;&lt;suspended&gt;&#125;</span></span><br></pre></td></tr></table></figure><p>技术上，这个由 <code>Symbol.iterator</code> 函数生成的对象应该通过其 <code>next()</code> 方法陆续返回值。可以通过显式地调用 <code>next()</code> 方法返回，也可以隐式地通过生成器函数返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Emitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">max</span> = max;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">idx</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">idx</span> &lt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">idx</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">count</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> emitter = <span class="keyword">new</span> <span class="title class_">Emitter</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> emitter) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">count</span>();</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h5 id="4-7-9-Symbol-match"><a href="#4-7-9-Symbol-match" class="headerlink" title="4.7.9 Symbol.match"></a>4.7.9 <code>Symbol.match</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个正则表达式方法，该方法用正则表达式去匹配字符串，由 <code>String.prototype.match()</code> 方法使用”。<code>String.prototype.match()</code> 方法会使用以 <code>Symbol.match</code> 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">match</span>]); <span class="comment">// f [Symbol.match]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="regexp">/bar/</span>)); <span class="comment">// [&quot;bar&quot;, index: 3, input: &quot;foobar&quot;, groups: undefined]</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，则可以重新定义 <code>Symbol.match</code> 函数以取代默认对正则表达式求值的行为，从而让 <code>match()</code> 方法使用非正则表达式实例。<code>Symbol.match</code> 函数接收一个参数，就是调用 <code>match()</code> 方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooMatcher</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>[<span class="title class_">Symbol</span>.<span class="property">match</span>](target)&#123;</span><br><span class="line">        <span class="keyword">return</span> target.<span class="title function_">includes</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="title class_">FooMatcher</span>)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringMatcher</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">str</span> = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">match</span>](target)&#123;</span><br><span class="line">        returntarget.<span class="title function_">includes</span>(<span class="variable language_">this</span>.<span class="property">str</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">StringMatcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="4-7-10-Symbol-replace"><a href="#4-7-10-Symbol-replace" class="headerlink" title="4.7.10 Symbol.replace"></a>4.7.10 <code>Symbol.replace</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个正则表达式方法，该方法替换一个字符串中匹配的子串，由 <code>String.prototype.replace()</code> 方法使用”。<code>String.prototype.replace()</code> 方法会使用以 <code>Symbol.replace</code> 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">replace</span>]); <span class="comment">// f [Symbol.replace]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobarbaz&#x27;</span>.<span class="title function_">replace</span>(<span class="regexp">/bar/</span>, <span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// &#x27;fooquxbaz&#x27;</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 <code>Symbol.replace</code> 函数以取代默认对正则表达式求值的行为，从而让 <code>replace()</code> 方法使用非正则表达式实例。<code>Symbol.replace</code> 函数接收两个参数，即调用 <code>replace()</code> 方法的字符串实例和替换字符串。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooReplacer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>[<span class="title class_">Symbol</span>.<span class="property">replace</span>](target, replacement)&#123;</span><br><span class="line">        returntarget.<span class="title function_">split</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="title function_">join</span>(replacement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">replace</span>(<span class="title class_">FooReplacer</span>, <span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// &quot;barquxbaz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringReplacer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">str</span> = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">replace</span>](target, replacement)&#123;</span><br><span class="line">        returntarget.<span class="title function_">split</span>(<span class="variable language_">this</span>.<span class="property">str</span>).<span class="title function_">join</span>(replacement);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">StringReplacer</span>(<span class="string">&#x27;foo&#x27;</span>), <span class="string">&#x27;qux&#x27;</span>)); <span class="comment">// &quot;barquxbaz&quot;</span></span><br></pre></td></tr></table></figure><h5 id="4-7-11-Symbol-search"><a href="#4-7-11-Symbol-search" class="headerlink" title="4.7.11 Symbol.search"></a>4.7.11 <code>Symbol.search</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个正则表达式方法，该方法返回字符串中匹配正则表达式的索引，由 <code>String.prototype.search()</code> 方法使用”。</p><p><code>String.prototype.search()</code> 方法会使用以 <code>Symbol.search</code> 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">search</span>]); <span class="comment">// f [Symbol.search]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="regexp">/bar/</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 <code>Symbol.search</code> 函数以取代默认对正则表达式求值的行为，从而让 <code>search()</code> 方法使用非正则表达式实例。<code>Symbol.search</code> 函数接收一个参数，就是调用 <code>match()</code> 方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooSearcher</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>[<span class="title class_">Symbol</span>.<span class="property">search</span>](target)&#123;</span><br><span class="line">        returntarget.<span class="title function_">indexOf</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoo&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">search</span>(<span class="title class_">FooSearcher</span>)); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringSearcher</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">str</span> = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">search</span>](target)&#123;</span><br><span class="line">        returntarget.<span class="title function_">indexOf</span>(<span class="variable language_">this</span>.<span class="property">str</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobar&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoo&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barbaz&#x27;</span>.<span class="title function_">search</span>(<span class="keyword">new</span> <span class="title class_">StringSearcher</span>(<span class="string">&#x27;qux&#x27;</span>))); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h5 id="4-7-12-Symbol-species"><a href="#4-7-12-Symbol-species" class="headerlink" title="4.7.12 Symbol.species"></a>4.7.12 <code>Symbol.species</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个函数值，该函数作为创建派生对象的构造函数”。这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 <code>Symbol.species</code> 定义静态的获取器（getter）方法，可以覆盖新创建实例的原型定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Baz</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">    staticget[<span class="title class_">Symbol</span>.<span class="property">species</span>]()&#123;</span><br><span class="line">        returnArray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Bar</span>);   <span class="comment">// true</span></span><br><span class="line">bar = bar.<span class="title function_">concat</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar <span class="keyword">instanceof</span> <span class="title class_">Bar</span>);   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> baz = <span class="keyword">new</span> <span class="title class_">Baz</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Baz</span>);   <span class="comment">// true</span></span><br><span class="line">baz = baz.<span class="title function_">concat</span>(<span class="string">&#x27;baz&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz <span class="keyword">instanceof</span> <span class="title class_">Baz</span>);   <span class="comment">// false </span></span><br></pre></td></tr></table></figure><h5 id="4-7-13-Symbol-split"><a href="#4-7-13-Symbol-split" class="headerlink" title="4.7.13 Symbol.split"></a>4.7.13 <code>Symbol.split</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 <code>String.prototype.split()</code> 方法使用”。<code>String.prototype.split()</code> 方法会使用以 <code>Symbol.split</code> 为键的函数来对正则表达式求值。正则表达式的原型上默认有这个函数的定义，因此所有正则表达式实例默认是这个 String 方法的有效参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">RegExp</span>.<span class="property"><span class="keyword">prototype</span></span>[<span class="title class_">Symbol</span>.<span class="property">split</span>]); <span class="comment">// f [Symbol.split]() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foobarbaz&#x27;</span>.<span class="title function_">split</span>(<span class="regexp">/bar/</span>)); <span class="comment">// [&#x27;foo&#x27;, &#x27;baz&#x27;]</span></span><br></pre></td></tr></table></figure><p>给这个方法传入非正则表达式值会导致该值被转换为 RegExp 对象。如果想改变这种行为，让方法直接使用参数，可以重新定义 <code>Symbol.split</code> 函数以取代默认对正则表达式求值的行为，从而让 <code>split()</code> 方法使用非正则表达式实例。<code>Symbol.split</code> 函数接收一个参数，就是调用 <code>match()</code> 方法的字符串实例。返回的值没有限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooSplitter</span> &#123;</span><br><span class="line">    <span class="keyword">static</span>[<span class="title class_">Symbol</span>.<span class="property">split</span>](target)&#123;</span><br><span class="line">        returntarget.<span class="title function_">split</span>(<span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">split</span>(<span class="title class_">FooSplitter</span>)); <span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringSplitter</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">str</span> = str;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">split</span>](target)&#123;</span><br><span class="line">        returntarget.<span class="title function_">split</span>(<span class="variable language_">this</span>.<span class="property">str</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;barfoobaz&#x27;</span>.<span class="title function_">split</span>(<span class="keyword">new</span> <span class="title class_">StringSplitter</span>(<span class="string">&#x27;foo&#x27;</span>))); <span class="comment">// [&quot;bar&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure><h5 id="4-7-14-Symbol-toPrimitive"><a href="#4-7-14-Symbol-toPrimitive" class="headerlink" title="4.7.14 Symbol.toPrimitive"></a>4.7.14 <code>Symbol.toPrimitive</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个方法，该方法将对象转换为相应的原始值。由 <code>ToPrimitive</code> 抽象操作使用”。很多内置操作都会尝试强制将对象转换为原始值，包括字符串、数值和未指定的原始类型。对于一个自定义对象实例，通过在这个实例的 <code>Symbol.toPrimitive</code> 属性上定义一个函数可以改变默认行为。</p><p>根据提供给这个函数的参数（string、number或default），可以控制返回的原始值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + foo); <span class="comment">// &quot;3[object Object]&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>- foo); <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(foo)); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]=<span class="keyword">function</span>(<span class="params">hint</span>)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(hint)&#123;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;number&#x27;</span>:</span><br><span class="line">                    return3;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;string&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span><span class="string">&#x27;stringbar&#x27;</span>;</span><br><span class="line">                <span class="keyword">case</span><span class="string">&#x27;default&#x27;</span>:</span><br><span class="line">                <span class="attr">default</span>:</span><br><span class="line">                    <span class="keyword">return</span><span class="string">&#x27;defaultbar&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + bar); <span class="comment">// &quot;3default bar&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>- bar); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(bar)); <span class="comment">// &quot;string bar&quot;</span></span><br></pre></td></tr></table></figure><h5 id="4-7-15-Symbol-toStringTag"><a href="#4-7-15-Symbol-toStringTag" class="headerlink" title="4.7.15 Symbol.toStringTag"></a>4.7.15 <code>Symbol.toStringTag</code></h5><p>根据 ECMAScript 规范，这个符号作为一个属性表示“一个字符串，该字符串用于创建对象的默认字符串描述，由内置方法 <code>Object.prototype.toString()</code> 使用”。</p><p>通过 <code>toString()</code> 方法获取对象标识时，会检索由 <code>Symbol.toStringTag</code> 指定的实例标识符，默认为 <code>&quot;Object&quot;</code>。内置类型已经指定了这个值，但自定义类实例还需要明确定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// Set(0) &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s.<span class="title function_">toString</span>()); <span class="comment">// [object Set]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// Set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// Foo &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">toString</span>()); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>] = <span class="string">&#x27;Bar&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar); <span class="comment">// Bar &#123;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="title function_">toString</span>()); <span class="comment">// [object Bar]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar[<span class="title class_">Symbol</span>.<span class="property">toStringTag</span>]); <span class="comment">// Bar</span></span><br></pre></td></tr></table></figure><h5 id="4-7-16-Symbol-unscopables"><a href="#4-7-16-Symbol-unscopables" class="headerlink" title="4.7.16 Symbol.unscopables"></a>4.7.16 <code>Symbol.unscopables</code></h5><p>根据 ECMAScript 规范，这个属性表示“一个对象，该对象所有的以及继承的属性，都会从关联对象的 <code>with</code> 环境绑定中排除”。设置这个符号并让其映射对应属性的键值为 <code>true</code>，就可以阻止该属性出现在 <code>with</code> 环境绑定中，如下例所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// bar</span></span><br><span class="line">&#125;</span><br><span class="line">o[<span class="title class_">Symbol</span>.<span class="property">unscopables</span>] = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">with</span> (o) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// ReferenceError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  不推荐使用 <code>with</code>，因此也不推荐使用 <code>Symbol.unscopables</code>。</p></blockquote><h4 id="4-8-Object类型"><a href="#4-8-Object类型" class="headerlink" title="4.8 Object类型"></a>4.8 Object类型</h4><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象通过 <code>new</code> 操作符后跟对象类型的名称来创建。开发者可以通过创建 Object 类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>如果没有参数，那么完全可以省略括号（不推荐）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>; <span class="comment">// 合法，但不推荐</span></span><br></pre></td></tr></table></figure><p>ECMAScript 中的 Object 是派生其他对象的基类，Object 类型的所有属性和方法在派生的对象上同样存在。</p><p>每个 Object 实例都有如下属性和方法：</p><ul><li><code>constructor</code>：用于创建当前对象的函数。在前面的例子中，这个属性的值就是Object()函数</li><li><code>hasOwnProperty(propertyName)</code>：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如 <code>o.hasOwnProperty(&quot;name&quot;)</code>）或符号</li><li><code>isPrototypeOf(object)</code>：用于判断当前对象是否为另一个对象的原型</li><li><code>propertyIsEnumerable(propertyName)</code>：用于判断给定的属性是否可以使用 <code>for-in</code> 语句枚举。与 <code>hasOwnProperty()</code> 一样，属性名必须是字符串</li><li><code>toLocaleString()</code>：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境</li><li><code>toString()</code>：返回对象的字符串表示</li><li><code>valueOf()</code>：返回对象对应的字符串、数值或布尔值表示。通常与 <code>toString()</code> 的返回值相同</li></ul><p>因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。</p>]]></content>
      
      
      <categories>
          
          <category> 《JavaScript高级程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01 JavaScript 概述</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-JavaScript的组成"><a href="#1-JavaScript的组成" class="headerlink" title="1. JavaScript的组成"></a>1. JavaScript的组成</h3><p>完整的 JavaScript 包含三个部分：</p><ul><li>核心（ECMAScript）</li><li>文档对象模型（DOM）</li><li>浏览器对象模型（BOM）</li></ul><h3 id="2-ECMAScript的符合性"><a href="#2-ECMAScript的符合性" class="headerlink" title="2.ECMAScript的符合性"></a>2.ECMAScript的符合性</h3><blockquote><p>  即要成为 ECMAScript 实现必须满足的条件</p></blockquote><ul><li>支持 ECMA-262 中描述的所有类型、值、对象、属性、函数，以及程序语法与语义</li><li>支持 Unicode 字符标准</li><li>增加 ECMA-262 中未提及的额外的类型、值、对象、属性和函数。</li><li>支持 ECMA-262 中没有定义的“程序和正则表达式语法”（意思是允许修改和扩展内置的正则表达式特性）</li></ul><h3 id="3-lt-script-gt-元素"><a href="#3-lt-script-gt-元素" class="headerlink" title="3. &lt;script&gt;元素"></a>3. <code>&lt;script&gt;</code>元素</h3><p>将 JavaScript 插入 HTML 的主要方法是使用 <code>&lt;script&gt;</code>元素。</p><p><code>&lt;script&gt;</code> 元素有下列 8 个属性：</p><ul><li><code>async</code>：可选；表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</li><li><code>charset</code>：可选；使用 <code>src</code> 属性指定的代码字符集。这个属性很少使用，因为大多数浏览器不在乎它的值。</li><li><code>crossorigin</code>：可选；配置相关请求的 CORS（跨源资源共享）设置。默认不使用 CORS。<code>crossorigin=&quot;anonymous&quot;</code> 配置文件请求不必设置凭据标志。<code>crossorigin=&quot;use-credentials&quot;</code> 设置凭据标志，意味着出站请求会包含凭据。</li><li><code>defer</code>：可选；表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。</li><li><code>integrity</code>：可选；允许比对接收到的资源和指定的加密签名以验证子资源完整性（SRI, Subresource Integrity）。如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行。这个属性可以用于确保内容分发网络（CDN, Content Delivery Network）不会提供恶意内容。</li><li><code>language</code>：废弃；大多数浏览器都会忽略这个属性，不应该再使用它。</li><li><code>src</code>：可选；表示包含要执行的代码的外部文件。</li><li><code>type</code>：可选；代替 <code>language</code>，表示代码块中脚本语言的内容类型（也称 MIME 类型）。按照惯例，这个值始终都是 <code>&quot;text/javascript&quot;</code>，尽管 <code>&quot;text/javascript&quot;</code> 和 <code>&quot;text/ecmascript&quot;</code> 都已经废弃了。JavaScript 文件的 MIME 类型通常是 <code>&quot;application/x-javascript&quot;</code>，不过给 <code>type</code> 属性这个值有可能导致脚本被忽略。在非 IE 的浏览器中有效的其他值还有<code>application/javascript</code> 和<code>application/ecmascript</code>。如果这个值是 <code>module</code>，则代码会被当成 ES6 模块，而且只有这时候代码中才能出现 <code>import</code> 和 <code>export</code> 关键字。</li></ul><p>使用 <code>&lt;script&gt;</code> 的方式有两种：通过它直接在网页中嵌入 JavaScript 代码，以及通过它在网页中包含外部 JavaScript 文件。</p><p>要嵌入行内 JavaScript 代码，直接把代码放在 <code>&lt;script&gt;</code> 元素中即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>&lt;script&gt;</code> 元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示。</p><p>在使用行内 JavaScript 代码时，要注意代码中不能出现字符串 <code>&lt;/script&gt;</code>，因为浏览器会将它解释为标签的结束，可以通过转义字符或者字符串拼接来避免，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">sayScript</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&lt;\/script&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要包含外部文件中的 JavaScript，就必须使用 <code>src</code> 属性。这个属性的值是一个 URL，指向包含 JavaScript 代码的文件，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与解释行内 JavaScript 一样，在解释外部 JavaScript 文件时，页面也会阻塞。（阻塞时间也包含下载文件的时间。）在 XHTML 文档中，可以忽略结束标签，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;example.js&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>但这种语法不能在 HTML 中使用。</p><blockquote><p>  按照惯例，外部 JavaScript 文件的扩展名是 <code>.js</code>。这不是必需的，因为浏览器不会检查所包含 JavaScript 文件的扩展名。这就为使用服务器端脚本语言动态生成 JavaScript 代码，或者在浏览器中将 JavaScript 扩展语言（如 TypeScript，或 React 的 JSX）转译为 JavaScript 提供了可能性。不过要注意，服务器经常会根据文件扩展来确定响应的正确 MIME 类型。如果不打算使用 <code>.js</code> 扩展名，一定要确保服务器能返回正确的 MIME 类型。</p></blockquote><p>使用了 <code>src</code> 属性的 <code>&lt;script&gt;</code> 元素不应该再在标签中再包含其他 JavaScript 代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。</p><p><code>&lt;script&gt;</code> 元素的 <code>src</code> 属性可以是一个完整的 URL，而且这个 URL 指向的资源可以跟包含它的 HTML 页面不在同一个域中，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.somewhere.com/afile.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，引用别人服务器上的 JavaScript 要格外小心，避免恶意程序，<code>&lt;script&gt;</code> 标签的 <code>integrity</code> 属性是防范这种问题的一个武器，但不是所有浏览器都支持。</p><p>浏览器会按照 <code>&lt;script&gt;</code> 在页面中出现的顺序依次解释它们，前提是没有使用 <code>defer</code> 和 <code>async</code> 属性。第二个 <code>&lt;script&gt;</code> 元素的代码必须在第一个 <code>&lt;script&gt;</code> 元素的代码解释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。</p><h3 id="4-标签位置"><a href="#4-标签位置" class="headerlink" title="4. 标签位置"></a>4. 标签位置</h3><p>过去，<code>&lt;script&gt;</code>都被放在页面的<code>&lt;head&gt;</code>标签内，主要目的是把外部的 CSS 和 JavaScript 文件都集中放到一起。不过，把所有 JavaScript 文件都放在 <code>&lt;head&gt;</code> 里，就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲染页面（页面在浏览器解析到 <code>&lt;body&gt;</code> 的起始标签时开始渲染）。对于需要很多 JavaScript 的页面，这会导致页面渲染的明显延迟，在此期间浏览器窗口完全空白。为解决这个问题，现代 Web 应用程序通常将所有 JavaScript 引用放在 <code>&lt;body&gt;</code>元素中的页面内容后面。这样一来，页面会在处理 JavaScript 代码之前完全渲染页面。用户会感觉页面加载更快了，因为浏览器显示空白页面的时间短了。</p><h3 id="5-推迟执行脚本"><a href="#5-推迟执行脚本" class="headerlink" title="5. 推迟执行脚本"></a>5. 推迟执行脚本</h3><p><code>&lt;script&gt;</code> 标签有一个 <code>defer</code> 的属性，表示脚本在执行的时候不会改变页面的结构，即脚本会被延迟到整个页面都解析完毕后再运行。因此，在 <code>&lt;script&gt;</code> 元素上设置 <code>defer</code> 属性，相当于告诉浏览器立即下载，但延迟执行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;! DOCTYPE html&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 页面内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>虽然 <code>&lt;script&gt;</code> 元素包含在页面的 <code>&lt;head&gt;</code> 中，但它们会在浏览器解析到结束的 <code>&lt;/html&gt;</code>标签后才会执行。HTML5 规范要求脚本应该按照它们出现的顺序执行，因此第一个推迟的脚本会在第二个推迟的脚本之前执行，而且两者都会在 DOMContentLoaded 事件之前执行。不过在实际当中，推迟执行的脚本不一定总会按顺序执行或者在 DOMContentLoaded 事件之前执行，因此最好只包含一个这样的脚本。</p><p><code>defer</code> 属性只对外部脚本文件才有效，浏览器会忽略行内脚本的 <code>defer</code> 属性，按照通常的做法来处理脚本。考虑到这一点，还是把要推迟执行的脚本放在页面底部比较好。</p><blockquote><p>  对于 XHTML 文档，指定 <code>defer</code> 属性时应该写成 <code>defer=&quot;defer&quot;</code>。</p></blockquote><h3 id="6-异步执行脚本"><a href="#6-异步执行脚本" class="headerlink" title="6. 异步执行脚本"></a>6. 异步执行脚本</h3><p><code>&lt;script&gt;</code> 标签定义了 <code>async</code> 属性。从改变脚本处理方式上看，<code>async</code> 属性与 <code>defer</code> 类似，都只适用于外部脚本，都会告诉浏览器立即开始下载。但标记为 <code>async</code> 的脚本并不保证能按照它们出现的次序执行，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;! DOCTYPE html&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 页面内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二个脚本可能先于第一个脚本执行，重点在于它们之间没有依赖关系。给脚本添加 <code>async</code> 属性的目的是告诉浏览器，不必等脚本下载和执行完后再加载页面，同样也不必等到该异步脚本下载和执行后再加载其他脚本。正因为如此，异步脚本不应该在加载期间修改 DOM 。异步脚本保证会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 之前或之后。一般不推荐使用这个属性。</p><blockquote><p>  对于 XHTML 文档，指定 <code>async</code> 属性时应该写成 <code>async=&quot;async&quot;</code>。</p></blockquote><h4 id="7-动态加载脚本"><a href="#7-动态加载脚本" class="headerlink" title="7. 动态加载脚本"></a>7. 动态加载脚本</h4><p>除了 <code>&lt;script&gt;</code> 标签，还有其他方式可以加载脚本。因为 JavaScript 可以使用 DOM API，所以通过向 DOM 中动态添加 script 元素同样可以加载指定的脚本。只要创建一个 script 元素并将其添加到 DOM 即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;example.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>默认情况下，以这种方式创建的 <code>&lt;script&gt;</code> 元素是以异步方式加载的，相当于添加了 <code>async</code> 属性。所有浏览器都支持 <code>createElement()</code> 方法，但不是所有浏览器都支持 <code>async</code> 属性。因此，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;example.js&#x27;</span>;</span><br><span class="line">script.<span class="property">async</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure><p>以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级，严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;gibberish.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="8-XHTML"><a href="#8-XHTML" class="headerlink" title="8. XHTML"></a>8. XHTML</h3><p>可扩展超文本标记语言（XHTML, Extensible HyperText Markup Language）是将 HTML 作为 XML 的应用重新包装的结果。与 HTML 不同，在 XHTML 中使用 JavaScript 需指定 <code>type</code> 属性且值为 <code>text/javascript</code>, HTML 中则可以没有这个属性。</p><p>XHTML 虽然已经退出历史舞台，但实践中偶尔可能也会遇到遗留代码。</p><p>在 XHTML 中编写代码的规则比 HTML 中严格，会影响使用 <code>&lt;script&gt;</code> 元素嵌入 JavaScript 代码。下面的代码块虽然在 HTML 中有效，但在 XHML 中是无效的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">a, b</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (a &lt; b) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is less than B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is greater than B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is equal to B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 HTML 中，解析 <code>&lt;script&gt;</code> 元素会应用特殊规则。XHTML 中则没有这些规则。这意味着 <code>a &lt; b</code> 语句中的 <code>&lt;</code> 会被解释成一个标签的开始，并且由于作为标签开始的小于号后面不能有空格，这会导致语法错误。</p><p>避免 XHTML 中这种语法错误的方法有两种。</p><p>第一种是把所有 <code>&lt;</code> 都替换成对应的 HTML 实体形式 <code>&amp;lt;</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">a, b</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (a &amp;lt; b) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is less than B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is greater than B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is equal to B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种方法是把所有代码都包含到一个 CDATA 块中。在 XHTML（及XML）中，CDATA 块表示文档中可以包含任意文本的区块，其内容不作为标签来解析，因此可以在其中包含任意字符，包括小于号，并且不会引发语法错误。使用 CDATA 的格式如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">&lt;![<span class="variable constant_">CDATA</span>[</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">a, b</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (a &lt; b) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is less than B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is greater than B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is equal to B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">]]&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在兼容 XHTML 的浏览器中，这样能解决问题。但在不支持 CDATA 块的非 XHTML 兼容浏览器中则不行。为此，CDATA 标记必须使用 JavaScript 注释来抵消：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &lt;![CDATA[</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">a, b</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (a &lt; b) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is less than B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is greater than B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;A is equal to B&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"><span class="comment">// ]]&gt;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种格式适用于所有现代浏览器，可以通过 XHTML 验证，而且对 XHTML 之前的浏览器也能优雅地降级。</p><blockquote><p>  XHTML 模式会在页面的 MIME 类型被指定为 <code>&quot;application/xhtml+xml&quot;</code> 时触发。并不是所有浏览器都支持以这种方式送达的 XHTML。</p></blockquote><h3 id="9-废弃的语法"><a href="#9-废弃的语法" class="headerlink" title="9. 废弃的语法"></a>9. 废弃的语法</h3><p><code>type</code> 属性使用一个 MIME 类型字符串来标识 <code>&lt;script&gt;</code> 的内容，但 MIME 类型并没有跨浏览器标准化。即使浏览器默认使用 JavaScript，在某些情况下某个无效或无法识别的 MIME 类型也可能导致浏览器跳过（不执行）相关代码。因此，除非你使用 XHTML 或 <code>&lt;script&gt;</code> 标签要求或包含非 JavaScript 代码，最佳做法是不指定 <code>type</code> 属性。</p><p>对 <code>script</code> 标签需应用特殊的解析规则，这在不支持 JavaScript 的浏览器（尤其是 Mosaic）中会导致问题。不支持的浏览器会把 <code>&lt;script&gt;</code> 元素的内容输出到页面上，从而破坏页面的外观。Netscape 联合 Mosaic 拿出了一个解决方案，对不支持 JavaScript 的浏览器隐藏嵌入的 JavaScript 代码。最终方案是把脚本代码包含在一个 HTML 注释中，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"><span class="comment">&lt;!--</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">    function sayHi() &#123;</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">        console.log(&quot;Hi!&quot;);</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">    &#125;</span></span></span></span><br><span class="line"><span class="comment"><span class="language-xml"><span class="language-handlebars">    // --&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用这种格式，Mosaic 等浏览器就可以忽略 <code>&lt;script&gt;</code> 标签中的内容，而支持 JavaScript 的浏览器则必须识别这种模式，将其中的内容作为 JavaScript 来解析。</p><p>虽然这种格式仍然可以被所有浏览器识别和解析，但已经不再必要，而且不应该再使用了。在 XHTML 模式下，这种格式也会导致脚本被忽略，因为代码处于有效的 XML 注释当中。</p><h3 id="10-行内代码和外部文件"><a href="#10-行内代码和外部文件" class="headerlink" title="10. 行内代码和外部文件"></a>10. 行内代码和外部文件</h3><p>虽然可以直接在 HTML 文件中嵌入 JavaScript 代码，但通常认为最佳实践是将 JavaScript 代码放在外部文件中，理由如下：</p><ul><li><strong>可维护性</strong>；JavaScript 代码如果分散到很多 HTML 页面，会导致维护困难。而用一个目录保存所有 JavaScript 文件，则更容易维护。</li><li><strong>缓存</strong>；浏览器会根据特定的设置缓存所有外部链接的 JavaScript 文件，这意味着如果两个页面都用到同一个文件，则该文件只需下载一次。这最终意味着页面加载更快。</li><li><strong>适应未来</strong>；通过把 JavaScript 放到外部文件中，就不必考虑 XHTML 的兼容性，外部 JavaScript 文件的语法在 HTML 和 XHTML 中是一样的。</li></ul><p>在配置浏览器请求外部文件时，要重点考虑的一点是它们会占用多少带宽。在 SPDY/HTTP2 中，预请求的消耗已显著降低，以轻量、独立 JavaScript 组件形式向客户端送达脚本更具优势。如，的一个页面包含如下脚本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;mainA.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>后续页面可能包含如下脚本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;mainB.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component3.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component4.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;component5.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在初次请求时，如果浏览器支持 SPDY/HTTP2，就可以从同一个地方取得一批文件，并将它们逐个放到浏览器缓存中。从浏览器角度看，通过 SPDY/HTTP2 获取所有这些独立的资源与获取一个大 JavaScript 文件的延迟差不多。在第二个页面请求时，由于你已经把应用程序切割成了轻量可缓存的文件，第二个页面也依赖的某些组件此时已经存在于浏览器缓存中了。当然，这里假设浏览器支持 SPDY/HTTP2，只有比较新的浏览器才满足。如果你还想支持那些比较老的浏览器，可能还是用一个大文件更合适。</p><h3 id="11-文档模式"><a href="#11-文档模式" class="headerlink" title="11. 文档模式"></a>11. 文档模式</h3><p>最初的文档模式有两种：<strong>混杂模式</strong>（quirks mode）和<strong>标准模式</strong>（standards mode）。前者使浏览器支持一些非标准的特性，后者让浏览器具有兼容标准的行为。虽然这两种模式的主要区别只体现在通过 CSS 渲染的内容方面，但对 JavaScript 也有一些关联影响，或称为<strong>副作用</strong>。</p><p>随着浏览器的普遍实现，又出现了第三种文档模式：<strong>准标准模式</strong>（almost standards mode）。这种模式下的浏览器支持很多标准的特性，但是没有标准规定得那么严格。主要区别在于如何对待图片元素周围的空白（在表格中使用图片时最明显）。混杂模式在浏览器中以省略文档开头的 <code>doctype</code> 声明作为开关。因为混杂模式在不同浏览器中的差异非常大，故不建议使用。</p><p>标准模式通过下列几种文档类型声明开启：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;! -- HTML 4.01 Strict --&gt;</span><br><span class="line"></span><br><span class="line">&lt;! DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;! -- XHTML 1.0 Strict --&gt;</span><br><span class="line"></span><br><span class="line">&lt;! DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;! -- HTML5--&gt;</span><br><span class="line"></span><br><span class="line">&lt;! DOCTYPE html&gt;</span><br></pre></td></tr></table></figure><p>准标准模式通过过渡性文档类型（Transitional）和框架集文档类型（Frameset）来触发：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;! -- HTML 4.01 Transitional --&gt;</span><br><span class="line"></span><br><span class="line">&lt;! DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;! -- HTML 4.01 Frameset --&gt;</span><br><span class="line"></span><br><span class="line">&lt;! DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;! -- XHTML 1.0 Transitional --&gt;</span><br><span class="line"></span><br><span class="line">&lt;! DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;! -- XHTML 1.0 Frameset --&gt;</span><br><span class="line"></span><br><span class="line">&lt;! DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><p>准标准模式与标准模式非常接近，很少需要区分。人们在说到“标准模式”时，可能指其中任何一个。</p><h3 id="12-lt-noscript-gt-标签"><a href="#12-lt-noscript-gt-标签" class="headerlink" title="12. &lt;noscript&gt;标签"></a>12. <code>&lt;noscript&gt;</code>标签</h3><p>针对早期浏览器不支持 JavaScript 的问题，出现了 <code>&lt;noscript&gt;</code> 标签，被用于给不支持 JavaScript 的浏览器提供替代内容。虽然如今的浏览器已经 100% 支持 JavaScript ，但对于禁用 JavaScript 的浏览器来说，这个元素仍然有用。</p><p><code>&lt;noscript&gt;</code> 元素可以包含任何可以出现在 <code>&lt;body&gt;</code> 中的 HTML 元素，<code>&lt;script&gt;</code> 除外。</p><p>在下列两种情况下，浏览器将显示包含在 <code>&lt;noscript&gt;</code> 中的内容：</p><ul><li>浏览器不支持脚本</li><li>浏览器对脚本的支持被关闭。</li></ul><p>任何一个条件被满足，包含在 <code>&lt;noscript&gt;</code> 中的内容就会被渲染。否则，浏览器不会渲染 <code>&lt;noscript&gt;</code> 中的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;! DOCTYPE html&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Example HTML Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span> <span class="attr">src</span>=<span class="string">&quot;example2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This page requires a JavaScript-enabled browser.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。</p>]]></content>
      
      
      <categories>
          
          <category> 《JavaScript高级程序设计》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Javascript </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
